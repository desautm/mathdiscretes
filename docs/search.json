[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mathématiques discrètes",
    "section": "",
    "text": "Préface\nCe document est un livre Quarto.\nPour en apprendre davantage sur les livres Quarto, visitez https://quarto.org/docs/books."
  },
  {
    "objectID": "systeme_numeration.html#système-décimal",
    "href": "systeme_numeration.html#système-décimal",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.1 Système décimal",
    "text": "1.1 Système décimal\nIl s’agit du système de numération le plus utilisé dans notre société. On peut le résumer avec les trois règles suivantes.\n\nBase = 10\nSymboles ordonnés qu’on nomme les chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.\nLe poids des symboles est donné par 10position\n\n\nExemple 1.1 Représentez le nombre 3482 sous une forme de numération positionnelle.\n\n\n\n\n\n\n\n\n\n\nSymboles (digits)\n3\n4\n8\n2\n\n\n\n\nRang (position)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\nPoids\n\n\n\n\n\n\nValeur du poids\n\n\n\n\n\n\nValeur de chaque symbole (digits)\n\n\n\n\n\n\n\nNous avons donc que 3482=\n\n\n\n\n\n\n\nImportant\n\n\n\nPour convertir un nombre de la base \\(b\\) vers la base 10 (décimal), on trouve sa représentation polynomiale.\n\n\n\nExemple 1.2 En utilisant la représentation polynomale en base 10, convertissez le nombre (176,21)8."
  },
  {
    "objectID": "systeme_numeration.html#système-binaire",
    "href": "systeme_numeration.html#système-binaire",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.2 Système binaire",
    "text": "1.2 Système binaire\nCe concept est essentiel en informatique, puisque les processeurs des ordinateurs sont composés de transistors ne gérant que deux états chacun (0 ou 1). Un calcul informatique n’est donc qu’une suite d’opérations sur des paquets de 0 et de 1, appelés bits.\n\nBase = 2\nSymboles ordonnés qu’on nomme les bits: 0, 1\nLe poids des symboles est donné par 2position\n\n\n\n\n\n\n\nImportant\n\n\n\nEn base 2, le chiffre 2 n’existe pas (c’est un nombre); tout comme le chiffre 10 n’existe pas en base 10 (c’est un nombre).\n\n\n\nExemple 1.3 Convertissez le nombre (11001)2 en décimal.\n\n\n\n\n\n\n\n\n\n\n\nSymboles (digits)\n1\n1\n0\n0\n1\n\n\n\n\nRang (position)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\nPoids\n\n\n\n\n\n\n\nValeur du poids\n\n\n\n\n\n\n\nValeur de chaque symbole (digits)\n\n\n\n\n\n\n\n\nNous avons donc que (11001)2 =\n\n\nExemple 1.4 Convertissez les nombres suivants en base 10 (décimal).\n\n(110)2 =\n(101101)2 =\n(0,1011)2 =\n(110,101)2 =\n\n\n\nExemple 1.5 Quels sont les nombres qui, dans la base deux, succèdent à (0)2?\n\n\nExemple 1.6 Quels sont les nombres qui, dans la base deux, succèdent à (1110)2?"
  },
  {
    "objectID": "systeme_numeration.html#système-hexadécimal",
    "href": "systeme_numeration.html#système-hexadécimal",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.3 Système hexadécimal",
    "text": "1.3 Système hexadécimal\nLe système hexadécimal est utilisé notamment en électronique numérique et en informatique car il est particulièrement commode et permet un compromis entre le code binaire des machines et une base de numération pratique à utiliser pour les ingénieurs. En effet, chaque chiffre hexadécimal correspond exactement à quatre chiffres binaires (ou bits), rendant les conversions très simples et fournissant une écriture plus compacte. L’hexadécimal a été utilisé la première fois en 1956 par les ingénieurs de l’ordinateur Bendix G-15.\n\nBase = 16\nSymboles ordonnés qu’on nomme les chiffres: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\nLe poids des symboles est donné par 16position\n\nOn remarque qu’en base 16, les dix chiffres de 0 à 9 ne suffisent pas. Il faut donc se doter de 6 symboles additionnels. On utilise les lettres de A à F avec la signification suivante:\n\\[\n(A)_{16}=(10)_{10}, \\quad (B)_{16}=(11)_{10}, \\quad (C)_{16}=(12)_{10}, \\quad (D)_{16}=(13)_{10}, \\quad (E)_{16}=(14)_{10}, \\quad (F)_{16}=(15)_{10}\n\\]\n\nExemple 1.7 Trouvez la représentation en base 10 de:\n\n(AB0)16\n(214,EA)16\n\n\n\nExemple 1.8 Donnez, en base 16, les dix nombres qui succèdent à (AAA)16."
  },
  {
    "objectID": "systeme_numeration.html#division-entière",
    "href": "systeme_numeration.html#division-entière",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.4 Division entière",
    "text": "1.4 Division entière\n\nDéfinition 1.3 (Divisibilité) Si \\(a\\in\\mathbb{Z}\\), \\(b\\in\\mathbb{Z}\\) et \\(a\\neq 0\\), on dit que \\(a\\) divise \\(b\\) s’il existe un entier \\(c\\) tel que \\(b=ac\\). L’entier \\(a\\) est alors appelé facteur de \\(b\\).\nSi \\(a\\) divise \\(b\\), nous le notons \\(a \\mid b\\).\n\n\nThéorème 1.1 (Divisibilité) Soit \\(a\\), \\(b\\) et \\(c\\) des nombres entiers quelconques, avec \\(a\\neq 0\\).\n\nSi \\(a\\mid b\\) et \\(a\\mid c\\) alors \\(a\\mid(b+c)\\) et \\(a\\mid (b-c)\\).\nSi \\(a\\mid b\\) alors \\(a\\mid (bc)\\).\nSi \\(a\\mid b\\) et \\(b\\mid c\\) alors \\(a\\mid c\\).\n\n\n\nExemple 1.9 Vrai ou faux? Justifiez en invoquant une définition, un théorème, en donnant une preuve ou un contre-exemple.\n\n\\(7\\mid 10\\)\n\\(-5\\mid 10\\)\n\\(100\\mid 10\\)\n\\(5\\mid -10\\)\n\n\n\nThéorème 1.2 Soit \\(a\\) et \\(d\\) des entiers, avec \\(d>0\\). Il existe une seule paire d’entiers \\(q\\) et \\(r\\) satisfaisant \\[\n0\\leq r<d \\quad \\text{et} \\quad a=dq+r\n\\]\n\n\nDéfinition 1.4 (Diviseur, dividende, quotient, reste) Considérons \\(a\\) et \\(d\\) des entiers, avec \\(d>0\\). Le Théorème 1.2 stipule qu’il existe une seule paire d’entiers \\(q\\) et \\(r\\) satisfaisant \\[\na=dq+r \\quad \\text{et} \\quad 0\\leq r<d\n\\]\nPar exemple, si \\(a=17\\) et \\(d=3\\), on a \\[\n17=3\\cdot 5+2 \\quad \\text{et} \\quad 0\\leq 2<3\n\\]\n\nL’entier \\(d=3\\) est appelé diviseur.\nL’entier \\(a=17\\) est appelé le dividende.\nL’entier \\(q=5\\) est appeléle quotient (notation: \\(q=a\\mathbf{div} d\\)).\nL’entier \\(r=2\\) est appelé le reste."
  },
  {
    "objectID": "systeme_numeration.html#conversions-de-la-base-10-vers-une-base-b",
    "href": "systeme_numeration.html#conversions-de-la-base-10-vers-une-base-b",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.5 Conversions de la base 10 vers une base \\(b\\)",
    "text": "1.5 Conversions de la base 10 vers une base \\(b\\)\nPour convertir un nombre entier de la base 10 vers une base \\(b\\), il faut effectuer de façon successive des divisions en utilisant la Définition 1.4. Les restes des divisions successives correspondent aux coefficients de la représentation polynomiale (lire de base en haut).\n\n1.5.1 Conversions vers binaire\n\nExemple 1.10 Convertissez les nombres suivants en binaire.\n\n115\n71\n\n\nNous pouvons utiliser la command bin de Python pour convertir des entiers décimaux en binaire.\n\nprint(bin(115))\n\n0b1110011\n\nprint(bin(71))\n\n0b1000111\n\n\nPour convertir un nombre fractionnaire en binaire, il suffit de multiplier (plutôt que de diviser) la partie fractionnaire en notant les parties entières et fractionnaires obtenues. Il faut ensuite répéter ces étapes avec la nouvelle partie fractionnaire et poursuivre le processus jusqu’à ce que la partie fractionnaire soit nulle. Les parties entières des résultats de ces produits correspondent aux coefficients de la représentation polynomiale (lire de haut en bas).\n\nExemple 1.11 Convertissez les nombres suivants en binaire.\n\n(0,8125)10\n(0,15)10\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa conversion en binaire ou en n’importe quelle base ne donne pas toujours une suite finie. Si c’est un nombre rationnel, la conversion donnera toujours une suite finie ou périodique.\n\n\n\nExemple 1.12 Convertissez en binaire les nombres suivants, en ne conservant que 6 chiffres pour la partie fractionnaire, au besoin.\n\n(51,375)10\n(564,32)10\n\n\n\n\n1.5.2 Conversions vers hexadécimal\n\nExemple 1.13 Convertissez les nombres décimaux suivants en hexadécimal.\n\n(176,47)10\n(69,28)10\n\n\nNous pouvons utiliser la command hex de Python pour convertir des entiers décimaux en hexadécimal.\n\nprint(hex(115))\n\n0x73\n\nprint(hex(71))\n\n0x47\n\n\n\n\n1.5.3 Conversions binaire - hexadécimal\nUne des raisons pour lesquelles le format hexadécimal a été inventé est qu’il est particulièrement simple de convertir un nombre binaire en nombre hexadécimal et inversement.\n\n\n\nHexa\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\nBinaire\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n\n\nHexa\n8\n9\nA\nB\nC\nD\nE\nF\n\n\nBinaire\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\n\n\nPour convertir un nombre binaire, on regroupe par paquets de 4 chiffres à partir de la virgule (pour la partie entière et la partie fractionnaire).\n\nExemple 1.14 Convertissez les nombres binaires suivants en hexadécimal.\n\n(111001,1101)2\n\\((1110001,11\\overline{001})_2\\)\n\n\n\nExemple 1.15 Convertissez les nombres hexadécimaux suivants en binaire.\n\n(537,14)16\n\\((45B,1\\overline{DE})_{16}\\)"
  },
  {
    "objectID": "systeme_numeration.html#applications-des-nombres-binaires-et-hexadécimaux",
    "href": "systeme_numeration.html#applications-des-nombres-binaires-et-hexadécimaux",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.6 Applications des nombres binaires et hexadécimaux",
    "text": "1.6 Applications des nombres binaires et hexadécimaux\n\n1.6.1 Vocabulaire des nombres binaires\nLes codes binaires sont incontournables en informatique, car l’information la plus élémentaire est le bit (binary-digit).\n\nQuartet\n\nNombre binaire composé de 4 éléments binaires.\n\nOctet (byte)\n\nNombre binaire composé de 8 éléments binaires.\n\nMot\n\nNombre binaire composé de 16, 32 ou 64 éléments binaires.\n\nLSB (Least Significant Bit)\n\nBit le moins significatif ou bit de poids faible (élément le plus à droite).\n\nMSB (Most Significant Bit)\n\nBit le plus significatif ou bit de poids fort (élément le plus à gauche).\n\n\n\n\n\n\n\n\nTruc\n\n\n\nLes mots de 8 ou de 16 bits écrits en binaire sont plus lisibles si on les inscrit en laissant un espace entre les groupes de quatre bits comme ceci: 0100 0001\n\n\n\n\n\n\n\n\nTruc\n\n\n\nOn a avantage à représenter les zéros non significatifs pour montrer la taille des codes transcrits. remarquez que ces 0 à gauche ne sont d’ailleurs pas toujours non significatifs. En effet, les codes binaires ne représentent pas toujours des valurs numériques. Ce sont parfois simplement des codes qui ne représentent pas des quantités. Inutile donc de faire de l’arithmétique avec ces codes. Dans ce cas, cela n’a aucun sens de vouloir les convertir en décimal et ce serait une erreur d’omettre l’écriture des zéros à gauche.\n\n\n\n\n1.6.2 Adresse IP\nUne adresse IP (Internet Protocol) est un numéro d’identification qui est attribué de façon permanente ou provisoire à chaque périphérique relié à un réseau informatique qui utilise l’Internet Protocol. L’adresse IP est à la base du système d’acheminement (le routage) des paquets de données sur Internet.\nIl existe des adresses IP de version 4 sur 32 bits, et de version 6 sur 128 bits. La version 4 est actuellement la plus utilisée : elle est généralement représentée en notation décimale avec quatre nombres compris entre 0 et 255, séparés par des points, ce qui donne par exemple « 181.174.87.53 ».\n\n\n\n\nAdresse Ipv4\n\n\n\n\n\nAdresse Ipv6\n\n\n\n\n\n1.6.3 Adresse MAC\nUne adresse MAC (de l’anglais Media Access Control), parfois nommée adresse physique, est un identifiant physique stocké dans une carte réseau ou une interface réseau similaire. À moins qu’elle n’ait été modifiée par l’utilisateur, elle est unique au monde. Le MAC (acronyme de Media Access Control) n’a aucun rapport avec le Mac d’Apple (diminutif de Macintosh). Toutes les cartes réseau ont une adresse MAC, même celles contenues dans les PC et autres appareils connectés (tablette tactile, smartphone, consoles de jeux, réfrigérateurs, montres …).\nOn peut utiliser Python et le module uuid pour trouver l’adresse MAC de l’appareil que j’utilise pour écrire ces lignes.\n\nimport uuid\nprint(hex(uuid.getnode()))\n\n0xc0b5d7b3d9a2\n\n\n\n\n1.6.4 Couleurs\nRouge, vert, bleu, de l’acronyme RVB ou en anglais RGB « red, green, blue ») désigne un système de traitement optique, d’affichage électronique ou d’un codage de signal vidéo analogique, ou un codage informatique des couleurs.\nCe principe est exploité par un téléviseur, un écran vidéo ou d’ordinateur, lequel reproduit la couleur par synthèse additive, à partir de trois couleurs primaires : rouge, vert et bleu.\nPour l’univers infographique, la valeur de chacune des couleurs primaires s’exprime dans un intervalle entre 0 et le maximum, qui est soit 1 ou 100 %, soit 255.\nL’informatique utilise des nombres codés en système binaire, par groupes de huit (octet). En attribuant un octet à chacun des canaux de couleur primaire, on obtient un nombre de couleurs tel que deux codes consécutifs, pour une ou plusieurs composantes, ne peuvent pas se distinguer sur un écran correctement réglé.\n\n\n\n\n\n\n\n\n\n\n\n\n\nValeur\nCouleur\nValeur\nCouleur\nValeur\nCouleur\nValeur\nCouleur\n\n\n\n\n#00FFFF\naqua / cyan\n#008000\ngreen (vert)\n#000080\nnavy (bleu marine)\n#C0C0C0\nsilver (argent)\n\n\n#000000\nblack (noir)\n#808080\ngray (gris)\n#808000\nolive (jaune olive)\n#008080\nteal (sarcelle)\n\n\n#0000FF\nblue (bleu)\n#00FF00\nlime (vert citron)\n#800080\npurple (violet)\n#FFFFFF\nwhite (blanc)\n\n\n#FF00FF\nfuchsia / magenta (fuchsia)\n#800000\nmaroon (bordeaux)\n#FF0000\nred (rouge)\n#FFFF00\nyellow (jaune)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCouleur\nValeur Rouge\nValeur Vert\nValeur Bleu\nHexadécimal\n\n\n\n\nRed (rouge)\n255 (FF)\n0 (00)\n0 (00)\n#FF0000\n\n\nGreen (vert)\n0 (00)\n255 (FF)\n0 (00)\n#00FF00\n\n\nBlue (bleu)\n0 (00)\n0 (00)\n255 (FF)\n#0000FF\n\n\nYellow (jaune)\n255 (FF)\n255 (FF)\n0 (00)\n#FFFF00\n\n\nOrange\n255 (FF)\n165 (A5)\n0 (00)\n#FFA500\n\n\nAqua\n0 (00)\n255 (FF)\n255 (FF)\n#00FFFF\n\n\nNavy blue (bleu marine)\n0 (00)\n0 (00)\n128 (80)\n#000080\n\n\nBlack (noir)\n0 (00)\n0 (00)\n0 (00)\n#000000\n\n\nWhite (blanc)\n255 (FF)\n255 (FF)\n255 (FF)\n#FFFFFF"
  },
  {
    "objectID": "systeme_numeration.html#addition-en-binaire",
    "href": "systeme_numeration.html#addition-en-binaire",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.7 Addition en binaire",
    "text": "1.7 Addition en binaire\nLa méthode pour l’addition en base 10 peut s’appliquer pour n’importe quelle base (principe de report). Pour additionner en binaire, on procède comme en décimal. Quand le résultat de la somme d’une colonne est supérieur à 1 (utilise plus de 1 bit), on reporte ce bit au voisin de gauche.\nEn binaire:\n\n\n\n+\n0\n1\n\n\n\n\n0\n0\n1\n\n\n1\n1\n10\n\n\n\n\nProcédure pour l’addition\n\nSuperposer les nombres en colonnes de telle sorte que les chiffres de même position soit alignés verticalement.\nAdditionner colonne par colonne, à partir de la droite, en effectuant les reports appropriés.\n\n\nExemple 1.16 Effectuez les additions demandées:\n\n(1011)2+(1001)2\n(1011,011)2+(110,01)2\n(110111,011)2+(10101,0101)2"
  },
  {
    "objectID": "systeme_numeration.html#représentation-des-entiers",
    "href": "systeme_numeration.html#représentation-des-entiers",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.8 Représentation des entiers",
    "text": "1.8 Représentation des entiers\nIl existe de nombreuses manières de représenter un nombre entier dans la mémoir d’un ordinateur. Nous n’en verrons que quelques unes.\n\n1.8.1 Entiers non signés\n\nDéfinition 1.5 (Entiers non signés (nombres positifs)) Un nombre entier non signé (positif) est représenté par un nombre de bits préalablement fixé. Au besoin, on complète le nombre par des zéros à gauche fin d’avoir le nombre total de bits choisi.\n\n\nExemple 1.17 Transformez les entiers décimaux suivants en entiers non signés sur un octet (huit bits).\n\n143\n15\n30\n\n\n\nExemple 1.18 Quel est le plus grand entier non signé pouvant être représenté avec:\n\n8 bits?\n32 bits?\n\\(n\\) bits?\n\n\n\n\n1.8.2 Entiers signés\nPour travailler avec des entiers qui peuvent être positifs ou négatifs, il faut inclure le signe du nombre dans sa représentation, et l’on parle alors d’entiers signés.\n\nDéfinition 1.6 (Entiers signés (représentation signe et module)) Un nombre entier signé (généralement représenté dans un octet) est un nombre où le 1er bit (à gauche) est réservé au signe, et les autres bits permettent d’indiquer la valeur absolue du nombre. Pour indique qu’un nombre est positif (+), le 1er bit est 0, et pour un nombre négatif (-), le 1er bit est 1.\n\n\nExemple 1.19 Complétez les tableaux suivants qui indiquent la représentation signe et module sur 4 bits.\n\n\n\n\n\nBase 2\nBase 10\n\n\n\n\n0000\n\n\n\n0001\n\n\n\n0010\n\n\n\n0011\n\n\n\n0100\n\n\n\n0101\n\n\n\n0110\n\n\n\n0111\n\n\n\n\n\n\n\n\n\n\nBase 2\nBase 10\n\n\n\n\n1000\n\n\n\n1001\n\n\n\n1010\n\n\n\n1011\n\n\n\n1100\n\n\n\n1101\n\n\n\n1110\n\n\n\n1111\n\n\n\n\n\n\n\nEn utilisant les nombres entiers signés:\n\nOn peut écrire autant de nombres positifs que de négatifs.\nPour un nombre exprimé avec \\(n\\) bits, les valeurs extrèmes sont \\(\\pm(2^{n-1}-1)\\)\n\n\nExemple 1.20 Quelles sont les valeurs extrèmes pour des entiers signés représentés sur 4 bits?\n\n\n\n\n\n\n\nInconvénients de la représentation signe et module\n\n\n\n\nIl y a deux zéros! Un zéro positif (0000 0000) et un zéro négatif (1000 0000).\nLes opérations arithmétiques ne se font pas de la même manière qu’habituellement. Par exemple, sur 4 bits:\n\nBase 2: 0100 + 1011 = 1111\nBase 10: +4 + -3 = -7! (FAUX!)\n\n\n\n\n\nExemple 1.21 Écrivez la représentation signe et module sur 8 bits de:\n\n15\n\n\n\n\n\n\n\n-15\n\n\n\n\n\n\n\n-10\n\n\n\n\n\n\n\nQuel est l’intervalle de nombres entiers signés pouvant être représentés avec:\n\n8 bits?\n16 bits?\n\n\n\n\n\n1.8.3 Complément à 1\nLe complément à un d’un nombre binaire est la valeur obtenue en inversant tous les bits de ce nombre (en permutant les 0 par des 1 et inversement). Le complément à un d’un nombre se comporte alors comme le négatif du nombre original dans certaines opérations arithmétiques.\nD’un point de vue algébrique, qui est plus général, c’est l’opération qui consiste à complémenter un nombre écrit en base \\(b\\) sur \\(n\\) chiffres à \\(b^n-1\\). C’est-à-dire que le complément d’un nombre \\(a\\) s’obtient par \\((b^n−1)−a\\).\n\nExemple 1.22 Le complément à 1 de 0100 =\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquons que dans l’Exemple 1.22, le complément à un représente le calcul de \\((2^4-1)-0100=1111-0100=1011\\)\n\n\n\nExemple 1.23 Représentez dans le tableau suivant toutes les valeurs possibles du complément à un sur 4 bits.\n\n\n\nDécimal\n+\n-\n\n\n\n\n0\n\\(\\phantom{000}\\)\n\\(\\phantom{000}\\)\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n\n\n\n\n1.8.4 Complément à 2\nDans le système de complément à un, la valeur 0 a deux représentations : « +0 » et « -0 » (exemple sur 4 bits: 0000 et 1111), ce qui oblige à réaliser deux tests pour tester la valeur nulle d’un résultat. Afin de pallier ce défaut, on a introduit la représentation par complément à deux.\nOn obtient le complément à deux en ajoutant 1 au complément à un. On ignore alors la retenue sur le bit de poids fort.\nLe complément à deux ne s’applique qu’à des nombres ayant tous la même longueur : avec un codage sur \\(n\\) bits, cette méthode permet de représenter toutes les valeurs entières de \\(−2^n − 1\\) à \\(2^{n − 1} − 1\\).\nTous les entiers en Python sont représentés en complémentation à deux et avec un nombre infini de bits (la limite est la capacité de mémoire de votre système). Par exemple:\n\nfrom sys import getsizeof\n\ncounter1 = 0\ncounter2 = 100\ncounter3 = 2**64\nsize1 = getsizeof(counter1)\nsize2 = getsizeof(counter2)\nsize3 = getsizeof(counter3)\nprint(size1, size2, size3)\n\n24 28 36\n\n\n\nRemarques\nDans la représentation en complément à deux:\n\nle bit de gauche est réservé au signe;\nles entiers négatifs sont représentés par leur complément à deux;\nles entiers positifs sont simplement représentés par leur nombre binaire signé;\nle nombre de bits est fixé.\n\n\n\n\n\n\n\nImportant\n\n\n\nIl n’est pas nécessaire de complémenter un nombre positif.\n\n\nLa complémentation à deux se fait en trois étapes:\n\nÉcrivez le nombre binaire sur le nombre de bits préalablement établi en ne tenant pas compte du signe (ajoutez des 0 à gauche au besoin).\nCalculez le complément à un (Remplacez tous les 0 par des 1 et tous les 1 par des 0).\nCalculez le complément à deux (Ajoutez 1 au complément à un).\n\n\nExemple 1.24 Écrivez le nombre \\(M=-4\\) dans sa représentation en complément à deux.\n\n\nExemple 1.25 Trouvez les compléments à deux des octets suivants.\n\n(0110 0100)\n(0110 1101)\n(0110 1001)\n\n\n\nExemple 1.26 Vous avez 8 bits.\n\nÉcrivez 5 en binaire sur 8 bits.\nComplémentez à deux la réponses précédente.\nAdditionnez les réponses obtenues en a) et en b).\n\n\n\n\n\n1.8.5 Addition de nombres par complémentation à deux\nPuisque les opérations internes de l’ordinateur ne permettent que l’addition, il faut troiver une manière d’effectuer une soustraction sans réellement en faire une. Par exemple, afin de calculer 10-4, il est possible de faire l’addition 10+(-4).\nAinsi, le complément à deux est nécessaire pour représenter les nombres négatifs et pour effectuer des soustractions.\n\n\n\n\n\n\nImportant\n\n\n\nIl est important de notes que:\n\nIl faut utiliser des nombres signés;\nPour deux nombres ayant le même nombre de bits, il se peut que le résultat de l’addition de ces nombres comporte un bit de plus. Dans ce cas, il faut ignorer le bit supplémentaire;\nSi le signe de la réponses n’a pas de sens, cela signifie que le résultat de l’addition est un nombre trop grand pour la capacité de l’ordinateur, on parle alors de débordement.\nSi le bit-signe est à 1, on doit complémenter le nombre pour retrouver le nombre négatif qui représente la réponse.\n\n\n\n\nAddition de deux nombres de mêmes signes\nCas particuliers:\n\nSi, après l’addition, le bit-signe est le même que les deux chiffres, le résultat est correct.\nSi le bit-signe est différent de celui des deux chiffres additionnés, il y a débordement.\n\n\nExemple 1.27 À l’aide de la complémentation à deux, calculez 49+25.\n\n\n\n\n\n\n\nExemple 1.28 À l’aide de la complémentation à deux, calculez 75+87.\n\n\n\n\n\n\n\nExemple 1.29 À l’aide de la complémentation à deux, calculez -64-56.\n\n\n\n\n\n\n\nExemple 1.30 À l’aide de la complémentation à deux, calculez -78-85.\n\n\n\n\n\n\n\n\nAddition de deux nombres de signes différents\n\nIl n’y a aucun débordement possible (POURQUOI?)\nLe résultat peut être positif ou négatif selon la valeur du bit-signe.\nOn complémente le résultat si le bit-signe est 1.\n\n\nExemple 1.31 À l’aide de la complémentation à deux, calculez -59-18.\n\n\n\n\n\n\n\nExemple 1.32 À l’aide de la complémentation à deux, calculez 18-59.\n\n\n\n\n\n\n\n\n\n1.8.6 Opérateurs bit à bit\nEn logique, une opération bit à bit est un calcul manipulant les données directement au niveau des bits, selon une arithmétique booléenne. Elles sont utiles dès qu’il s’agit de manipuler les données à bas niveau : codages, couches basses du réseau (par exemple TCP/IP), cryptographie, etc.\nLes opérations bit à bit courantes comprennent des opérations logiques bit par bit et des opérations de décalage des bits, vers la droite ou vers la gauche.\n\n\n1.8.7 LEFT-SHIFT <<\n\n\n1.8.8 RIGHT-SHIFT >>\n\n\n1.8.9 COMPLÉMENT À UN ~ (MÊME CHOSE QUE NOT)"
  },
  {
    "objectID": "systeme_numeration.html#représentation-des-nombres-en-virgule-flottante",
    "href": "systeme_numeration.html#représentation-des-nombres-en-virgule-flottante",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.9 Représentation des nombres en virgule flottante",
    "text": "1.9 Représentation des nombres en virgule flottante\n\n1.9.1 La norme IEEE754\nEn informatique, l’IEEE 754 est une norme sur l’arithmétique à virgule flottante mise au point par le Institute of Electrical and Electronics Engineers. Elle est la norme la plus employée actuellement pour le calcul des nombres à virgule flottante avec les CPU et les FPU. La norme définit les formats de représentation des nombres à virgule flottante (signe, mantisse, exposant, nombres dénormalisés) et valeurs spéciales (infinis et NaN), en même temps qu’un ensemble d’opérations sur les nombres flottants. Il décrit aussi cinq modes d’arrondi et cinq exceptions (comprenant les conditions dans lesquelles une exception se produit, et ce qui se passe dans ce cas).\n\nFormat général\nUn nombre flottant est formé de trois éléments : la mantisse, l’exposant et le signe. Le bit de poids fort est le bit de signe : si ce bit est à 1, le nombre est négatif, et s’il est à 0, le nombre est positif. Les \\(e\\) bits suivants représentent l’exposant biaisé (sauf valeur spéciale), et les \\(m\\) bits suivants (\\(m\\) bits de poids faible) représentent la mantisse.\n\n\n\n\nFormat général d’un nombre en virgule flottante.\n\n\n\nL’exposant peut être positif ou négatif. Cependant, la représentation habituelle des nombres signés (complément à 2) rendrait la comparaison entre les nombres flottants un peu plus difficile. Pour régler ce problème, l’exposant est « biaisé », afin de le stocker sous forme d’un nombre non signé.\nCe biais est de 2e−1 − 1 (e représente le nombre de bits de l’exposant) ; il s’agit donc d’une valeur constante une fois que le nombre de bits e est fixé."
  },
  {
    "objectID": "logique.html#logique-propositionnelle",
    "href": "logique.html#logique-propositionnelle",
    "title": "2  Logique",
    "section": "2.1 Logique propositionnelle",
    "text": "2.1 Logique propositionnelle\n\nDéfinition 2.1 (Proposition) Un énoncé qui est soit vrai, soit faux est appelé une proposition. La valeur de vérité d’une proposition est donc VRAI ou FAUX.\nEn Python, les valeurs de vérités sont données par True (VRAI) et False (FAUX).\n\nUn énoncé qui n’est pas une proposition (comme un paradoxe, une phrase impérative ou interrogative) sera qualifié d’innaceptable.\n\nExemple 2.1 Les énoncés suivants sont des propositions:\n\nLes numéros de téléphones au Canada ont dix chiffres.\nLa lune est faite de fromage.\n42 est la réponse à la question portant sur la vie, l’univers et tout ce qui existe.\nChaque nombre pair plus grand que 2 peut être exprimé comme la somme de deux nombres premiers.\n\\(3+7=12\\)\n\nLes énoncés suivants ne sont pas des propositions:\n\nVoulez-vous du gâteau?\nLa somme de deux carrés.\n\\(1+3+5+7+\\ldots +2n+1\\).\nVa dans ta chambre!\n\\(3+x=12\\)\n\n\nNous utilisons une table de vérité pour montrer les valeurs de vérité de propositions composées.\n\n2.1.1 La négation\n\nDéfinition 2.2 (La négation) Soit \\(p\\) une proposition. L’énoncé:\n\nIl n’est pas vrai que \\(p\\).\n\nest une autre proposition appelée négation de \\(p\\), qui est représentée par \\(\\lnot p\\). La proposition \\(\\lnot p\\) se lit non \\(p\\). La table de vérité de la négation est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(\\lnot p\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, l’opérateur not permet de faire la négation d’une valeur de vérité.\n\ndef negation(p):\n    return not p\n\nprint(\"p    non_p\")\nfor p in [True, False]:\n    non_p = negation(p)\n    print(p, non_p)\n\np    non_p\nTrue False\nFalse True\n\n\n\n\n\n2.1.2 La conjonction\n\nJe suis une roche ET je suis une île.\n\n\nDéfinition 2.3 (La conjonction) Soit \\(p\\) et \\(q\\) deux propositions. La proposition \\(p\\) et \\(q\\), notée \\(p\\wedge q\\), est vraie si à la fois \\(p\\) et \\(q\\) sont vraies. Elle est fausse dans tous les autres cas. Cette proposition est appelée la conjonction de \\(p\\) et de \\(q\\). La table de vérité de la conjonction est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\wedge q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, l’opérateur and permet de faire la conjonction de deux valeurs de vérité.\n\ndef conjonction(p, q):\n    return p and q\n\nprint(\"p    q    p_et_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_et_q = conjonction(p, q)\n        print(p, q, p_et_q)\n\np    q    p_et_q\nTrue True True\nTrue False False\nFalse True False\nFalse False False\n\n\n\n\n\n2.1.3 La disjonction\n\nElle a étudié très fort OU elle est extrêmement brillante.\n\n\nDéfinition 2.4 (La disjonction) Soit \\(p\\) et \\(q\\) deux propositions. La proposition \\(p\\) ou \\(q\\), notée \\(p\\vee q\\), est fausse si \\(p\\) et \\(q\\) sont fausses. Elle est vraie dans tous les autres cas. Cette proposition est appelée la disjonction de \\(p\\) et de \\(q\\). La table de vérité de la disjonction est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\vee q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, l’opérateur or permet de faire la disjonction de deux valeurs de vérité.\n\ndef disjonction(p, q):\n    return p or q\n\nprint(\"p    q    p_ou_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_ou_q = disjonction(p, q)\n        print(p, q, p_ou_q)\n\np    q    p_ou_q\nTrue True True\nTrue False True\nFalse True True\nFalse False False\n\n\n\n\n\n2.1.4 La disjonction exclusive\n\nPrenez SOIT deux Advil OU deux Tylenols.\n\n\nDéfinition 2.5 (La disjonction exclusive) Soit \\(p\\) et \\(q\\) deux propositions. La proposition \\(p\\) ou exclusif \\(q\\), notée \\(p\\oplus q\\), est vraie si \\(p\\) et \\(q\\) ont des valeurs de vérité différentes. Elle est fausse dans tous les autres cas. Cette proposition est appelée la disjonction exclusive de \\(p\\) et de \\(q\\). La table de vérité de la disjonction exclusive est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\oplus q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, il n’existe pas d’opérateur logique pour effectuer la disjonction exclusive. On peut par contre utiliser l’opérateur bit à bit ^ pour faire cette disjonction exclusive.\n\n\nExemple 2.2 Utilisez les opérateurs logiques vus précédemment pour construire la table de vérité de la disjonction exclusive dans Python.\n\ndef disjonction_exclusive(p, q):\n    return #REMPLACEZ MOI#\n\nprint(\"p    q    p_ou_exclusif_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_ou_exclusif_q = disjonction_exclusive(p, q)\n        print(p, q, p_ou_exclusif_q)\n\n\n\np    q    p_ou_exclusif_q\nTrue True False\nTrue False True\nFalse True True\nFalse False False\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa disjonction exclusive signifie l’un ou l’autre, mais pas les deux.\n\n\n\n\n2.1.5 L’implication\n\nSI vous avez 100 à l’examen final, ALORS vous obtiendrez A dans ce cours.\n\n\nDéfinition 2.6 (L’implication) Soit \\(p\\) et \\(q\\) deux propositions. L’implication \\(p\\rightarrow q\\) est une proposition qui est fausse quand \\(p\\) est vraie et que \\(q\\) est fausse, et qui est vraie dans tous les autres cas. Dans une implication, \\(p\\) est appelée l’hypothèse (ou l’antécédent ou la prémisse) et \\(q\\), la conclusion (ou la conséquence). La table de vérité de l’implication’ est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\rightarrow q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, il n’existe pas d’opérateur logique pour effectuer l’implication.\n\n\nExemple 2.3 Utilisez les opérateurs logiques vus précédemment pour construire la table de vérité de l’implication dans Python.\n\ndef implication(p, q):\n    return #REMPLACEZ MOI#\n\nprint(\"p    q    p_implique_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_implique_q = implication(p, q)\n        print(p, q, p_implique_q)\n\n\n\np    q    p_implique_q\nTrue True True\nTrue False False\nFalse True True\nFalse False True\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nUne implication peut être considérée comme un contrat qui échoue seulement si les conditions du contrat sont respectées mais les résultats ne sont pas remplis.\n\n\nComme les implications apparaissent constamment en mathématiques, il existe une vaste terminologie pour désigner \\(p\\rightarrow q\\). Voici les modes les plus courants:\n\nsi \\(p\\) alors \\(q\\);\n\\(p\\) implique \\(q\\);\n\\(p\\) seulement si \\(q\\);\n\\(p\\) est suffisant pour \\(q\\);\n\\(q\\) si \\(p\\);\n\\(q\\) chaque fois que \\(p\\);\n\\(q\\) est nécessaire à \\(p\\).\n\n\n\n2.1.6 La biconditionnelle\n\nIl pleut dehors SI ET SEULEMENT SI c’est un jour nuageux.\n\n\nDéfinition 2.7 (La biconditionnelle) Soit \\(p\\) et \\(q\\) deux propositions. La biconditionnelle \\(p\\leftrightarrow q\\) est une proposition qui est vraie quand \\(p\\) et \\(q\\) ont les mêmes valeurs de vérité et qui est fausse dans les autres cas. La table de vérité de la biconditionnelle est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\leftrightarrow q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, il n’existe pas d’opérateur logique pour effectuer la biconditionnelle.\n\n\nExemple 2.4 Utilisez les opérateurs logiques vus précédemment pour construire la table de vérité de la biconditionnelle dans Python.\n\ndef biconditionnelle(p, q):\n    return #REMPLACEZ MOI#\n\nprint(\"p    q    p_biconditionnelle_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_biconditionnelle_q = biconditionnelle(p, q)\n        print(p, q, p_biconditionnelle_q)\n\n\n\np    q    p_biconditionnelle_q\nTrue True True\nTrue False False\nFalse True False\nFalse False True\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa biconditionnelle est vraie si les propositions ont la même valeur de vérité et fausse autrement.\n\n\nComme les biconditionnelles apparaissent constamment en mathématiques, il existe une vaste terminologie pour désigner \\(p\\leftrightarrow q\\). Voici les modes les plus courants:\n\n\\(p\\) si et seulement si \\(q\\);\n\\(p\\) est nécessaire et suffisante pour \\(q\\);\nsi \\(p\\) alors \\(q\\) et réciproquement.\n\n\nDéfinition 2.8 (Réciproque, contraposée et inverse)  \n\nLa réciproque de la proposition \\(p\\rightarrow q\\) est la proposition \\(q \\rightarrow p\\).\nLa contraposée de la proposition \\(p\\rightarrow q\\) est la proposition \\(\\lnot q \\rightarrow \\lnot p\\).\nL’inverse de la proposition \\(p\\rightarrow q\\) est la proposition \\(\\lnot p \\rightarrow \\lnot q\\)."
  },
  {
    "objectID": "logique.html#équivalences-propositionnelles",
    "href": "logique.html#équivalences-propositionnelles",
    "title": "2  Logique",
    "section": "2.2 Équivalences propositionnelles",
    "text": "2.2 Équivalences propositionnelles\nUne proposition composée est une proposition formée de plusieurs connecteurs logiques.\n\nDéfinition 2.9 (Tautologie, contradiction et contingence) Une proposition composée qui est toujours vraie, quelle que soit la valeur de vérité des fonctions qui la compose est appelée une tautologie. Une proposition composée qui est toujours fausse est appelée une contradiction. Finalement, une proposition qui n’est ni une tautologie ni une contradiction est appelée une contingence.\n\n\nExemple 2.5 Remplissez la table de vérité suivante et dites si les propositions composées sont des tautologies, des contradictions ou des contingences.\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\vee \\lnot p\\)\n\\(p \\wedge \\lnot p\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\n\nExemple 2.6 Le code ci-dessous révèle la table de vérité de la proposition composée \\((p \\wedge q) \\vee \\lnot q\\).\n\ndef conjonction(p, q):\n    return p and q\n\ndef disjonction(p, q):\n    return p or q\n\nprint(\"p    q    a\")\nfor p in [True, False]:\n    for q in [True, False]:\n        a = disjonction(conjonction(p, q), not q)\n        print(p, q, a)\n\np    q    a\nTrue True True\nTrue False True\nFalse True False\nFalse False True\n\n\nDe quelle manière pouvez-vous modifier le code précédent pour obtenir la table de vérité de la proposition composée \\((p \\vee \\lnot q) \\wedge \\lnot p\\)?\n\nLorsque vous créez votre table de vérité, il est crucial que vous soyiez systématique pour vous assurer d’avoir toutes les valeurs de vérité possibles pour chacune des propositions simples. Chaque proposition a deux valeurs de vérité possibles, le nombre de lignes de la table devrait être égal à \\(2^n\\), où \\(n\\) est le nombre de propositions. Vous devriez également considérer de briser vos propositions complexes en plus petites propositions.\n\nExemple 2.7 L’extrait de code suivant fait intervenir les variables booléennes \\(p\\), \\(q\\) et \\(r\\). Chacune de ces variables peut prendre les valeurs vrai ou faux. Pour chaque bloc indiqué, donnez toutes les valeurs possibles pour \\(p\\), \\(q\\) et \\(r\\) au moment où le bloc est atteint.\n\nif (p and q):\n    if r:\n        #BLOC 1#\n    else:\n        #BLOC 2#\nelse:\n    #BLOC 3#\n\n\n\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(r\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\nV\n\n\n\n\n\nV\nV\nF\n\n\n\n\n\nV\nF\nV\n\n\n\n\n\nV\nF\nF\n\n\n\n\n\nF\nV\nV\n\n\n\n\n\nF\nV\nF\n\n\n\n\n\nF\nF\nV\n\n\n\n\n\nF\nF\nF\n\n\n\n\n\n\n\n\nDéfinition 2.10 (Équivalences de propositions) Les propositions \\(p\\) et \\(q\\) sont dites logiquement équivalentes si la proposition \\(p \\leftrightarrow q\\) est une tautologie. Ainsi, deux propositions sont logiquement équivalentes si elles ont la même table de vérité, c’est-à-dire la même valeur de vérité dans tous les cas possibles.\nLa notation \\(p\\equiv q\\) signifie que \\(p\\) et \\(q\\) sont équivalentes.\n\n\nExemple 2.8 Vérifiez l’équivalence suivante à l’aide d’une table de vérité. \\[\np \\rightarrow q \\equiv \\lnot p \\vee q\n\\]\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\n\n\n\n\n\nV\nF\n\n\n\n\n\nF\nV\n\n\n\n\n\nF\nF\n\n\n\n\n\n\n\n\nExemple 2.9 Vérifiez l’équivalence suivante à l’aide d’une table de vérité. \\[\n\\lnot (p \\vee q) \\equiv \\lnot p \\wedge \\lnot q\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\n\n\n\n\n\n\n\nV\nF\n\n\n\n\n\n\n\nF\nV\n\n\n\n\n\n\n\nF\nF\n\n\n\n\n\n\n\n\n\nPour gagner du temps, on note les équivalences fréquemment utilisées dans une table et on leur donne un nom ou un numéro afin d’y faire référence.\n\n\nTable 2.1: Équivalences logiques\n\n\n\n\n\n\n\nNom\nÉquivalence 1\nÉquivalence 2\n\n\n\n\nIdentité\n\\(p \\wedge \\mathbf{V} \\equiv p\\)\n\\(p \\vee \\mathbf{F} \\equiv p\\)\n\n\nDomination\n\\(p \\vee \\mathbf{V} \\equiv \\mathbf{V}\\)\n\\(p \\wedge \\mathbf{F} \\equiv \\mathbf{F}\\)\n\n\nIdempotence\n\\(p \\vee p \\equiv p\\)\n\\(p\\wedge p \\equiv p\\)\n\n\nDouble négation\n\\(\\lnot (\\lnot p) \\equiv p\\)\n\n\n\nCommutativité\n\\(p\\wedge q \\equiv q \\wedge p\\)\n\\(p \\vee q \\equiv q \\vee p\\)\n\n\nAssociativité\n\\((p \\vee q) \\vee r \\equiv p \\vee (q \\vee r)\\)\n\\((p \\wedge q) \\wedge r \\equiv p \\wedge (q \\wedge r)\\)\n\n\nDistributivité\n\\(p \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r)\\)\n\\(p\\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)\\)\n\n\nLois de De Morgan\n\\(\\lnot (p \\wedge q) \\equiv \\lnot p \\vee \\lnot q\\)\n\\(\\lnot (p \\vee q) \\equiv \\lnot p \\wedge \\lnot q\\)\n\n\nAbsorption\n\\(p \\vee (p \\wedge q) \\equiv p\\)\n\\(p \\wedge (p \\vee q) \\equiv p\\)\n\n\nNégation\n\\(p \\vee \\lnot p \\equiv \\mathbf{V}\\)\n\\(p \\wedge \\lnot p \\equiv \\mathbf{F}\\)\n\n\n\n\n\n\nTable 2.2: Équivalences logiques (implications)\n\n\n\n\n\n\nNuméro\nImplication\n\n\n\n\n1\n\\(p \\rightarrow q \\equiv \\lnot p \\vee q\\)\n\n\n2\n\\(p \\rightarrow q \\equiv \\lnot q \\rightarrow \\lnot p\\)\n\n\n3\n\\(p \\vee q \\equiv \\lnot p \\rightarrow q\\)\n\n\n4\n\\(p \\wedge q \\equiv \\lnot(p \\rightarrow \\lnot q)\\)\n\n\n5\n\\(\\lnot(p \\rightarrow q) \\equiv p \\wedge \\lnot q\\)\n\n\n6\n\\((p \\rightarrow q)\\wedge (p\\rightarrow r) \\equiv p \\rightarrow (q \\wedge r)\\)\n\n\n7\n\\((p \\rightarrow r) \\wedge (q \\rightarrow r) \\equiv (p \\vee q) \\rightarrow r\\)\n\n\n8\n\\((p\\rightarrow q) \\vee (p \\rightarrow r) \\equiv p \\rightarrow (q \\vee r)\\)\n\n\n9\n\\((p \\rightarrow r) \\vee (q \\rightarrow r) \\equiv (p \\wedge q) \\rightarrow r\\)\n\n\n\n\n\n\nTable 2.3: Équivalences logiques (biconditionnelles)\n\n\n\n\n\n\nNuméro\nBiconditionnelle\n\n\n\n\n1\n\\(p \\leftrightarrow q \\equiv (p\\rightarrow q) \\wedge (q \\rightarrow q)\\)\n\n\n2\n\\(p \\leftrightarrow q \\equiv \\lnot p \\leftrightarrow \\lnot q\\)\n\n\n3\n\\(p \\leftrightarrow q \\equiv (p \\wedge q) \\vee (\\lnot p \\wedge \\lnot q)\\)\n\n\n4\n\\(p \\leftrightarrow q \\equiv \\lnot(p \\wedge \\lnot q) \\wedge \\lnot(\\lnot p \\wedge q )\\)\n\n\n5\n\\(\\lnot(p \\leftrightarrow q) \\equiv p \\leftrightarrow \\lnot q\\)\n\n\n\n\n\nExemple 2.10 Vérifiez que la proposition \\[\n\\lnot (p \\rightarrow q) \\rightarrow \\lnot q\n\\] est une tautologie\n\nà l’aide d’une table de vérité;\n\n\n\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\n\n\n\n\n\n\n\nV\nF\n\n\n\n\n\n\n\nF\nV\n\n\n\n\n\n\n\nF\nF\n\n\n\n\n\n\n\n\nsans l’aide d’une table de vérité, en utilisant les tableaux d’équivalences.\n\n\n\n\n\n\n\n\nPropositions équivalentes ou non?\n\n\n\nPour démontrer que les propositions ne sont pas équivalentes, il suffit de fournir des valeurs de \\(p\\), \\(q\\) et \\(r\\) pour lesquelles elles diffèrent. Pour démontrer que les propositions sont équivalentes, on peut procéder de l’une des trois façons suivantes.\n\nFournir leur table de vérité.\nUtiliser la Table 2.1, la Table 2.2 ou la Table 2.3.\nFormuler une explication en mots qui montre que les deux propositions sont vraies, ou encore que les deux sont fausses, exactement pour les mêmes combinaisons de valeur de vérité des variables propositionnelles."
  },
  {
    "objectID": "logique.html#prédicats-et-quantificateurs",
    "href": "logique.html#prédicats-et-quantificateurs",
    "title": "2  Logique",
    "section": "2.3 Prédicats et quantificateurs",
    "text": "2.3 Prédicats et quantificateurs\nUn énoncé contenant une ou plusieurs variables tel que \\[\nx<10 \\quad \\text{ou} \\quad x+2=7-y\n\\] n’est pas une proposition pusique, tant que la valeur de \\(x\\) ou \\(y\\) n’est pas connue, on ne peut dire s’il est vrai ou faux.\n\nDéfinition 2.11 (Terminologie) Dans l’énoncé “\\(x<10\\)”, \\(x\\) est le sujet, et “est inférieur à 10” est le prédicat. Notons \\(P(x)\\) l’énoncé \\(x<10\\). On dit que \\(P\\) est une fonction propositionnelle.\n\nUne fonction propositionnelle \\(P(x)\\) prend la valeur vrai ou faux quand \\(x\\) est précisé. Par exemple:\n\n\\(P(8)\\) est une proposition vraie. On écrira parfois \\(P(8)\\) est vrai (au masculin, en sous-entendant l’énoncé est vrai, ou même \\(P(8)\\equiv \\mathbf{V}\\)).\n\\(P(13)\\) est une proposition fausse.\n\\(P(\\text{Marc-André})\\) n’est pas une proposition, car Marc-André n’est pas une valeur possible pour la variable \\(x\\).\n\nL’ensemble des valeurs possibles pour la variable \\(x\\) est appelé univers du discours, ou domaine de la fonction \\(P\\).\n\nDéfinition 2.12 (Quantificateurs) \\[\n\\forall:\\ \\text{quantificateur universel} \\qquad \\exists:\\ \\text{quantificateur existentiel}\n\\]\n\n\\(\\forall\\ x\\ P(x)\\):\n\nsignifie “Pour toutes les valeurs de \\(x\\) dans l’univers du discours, \\(P(x)\\)”. Ou encore “Quel que soit \\(x\\) (dans l’univers du discours), \\(P(x)\\)”.\n\n\\(\\exists\\ x\\ P(x)\\):\n\nsignifie “Il existe un élément de \\(x\\) dans l’univers du discours tel que \\(P(x)\\)”. Ou encore “Il y a au moins un \\(x\\) (dans l’univers du discours) tel que \\(P(x)\\)”. Ou encore “Pour un certain \\(x\\) (dans l’univers du discours), \\(P(x)\\)”.\n\n\nNotation. Certains auteurs mettent une virgule avant la fonction propositionnelle, surtout quand celle-ci est composée. Par exemple: \\(\\forall\\ x,\\ (P_1(x)\\rightarrow P_2(x) \\vee P_3(x))\\). Par ailleurs, si l’ensemble \\(U\\) n’a pas déjà été identifié, on peut préciser que la variable \\(x\\) prendra des valeurs dans l’ensemble \\(U\\) ainsi: \\(\\exists\\ x\\in U,\\ P(x)\\).\n\nLorsque l’univers du discours est un ensemble fini \\(\\{x_1,x_2,\\ldots, x_n\\}\\), on a les équivalences logiques suivantes:\n\\[\\begin{align*}\n\\forall\\ x\\ P(x) &\\equiv P(x_1)\\wedge P(x_2) \\wedge \\cdots \\wedge P(x_n) \\\\\n\\exists\\ x\\ P(x) &\\equiv P(x_1)\\vee P(x_2) \\vee \\cdots \\vee P(x_n)\n\\end{align*}\\]\nLa quantification universelle \\(\\forall\\ x\\ P(x)\\) est vraie quand \\(P(x)\\) est vraie pour toutes les valeurs de \\(x\\) dans l’univers du discours \\(U\\). Elle est donc fausse s’il existe un \\(x\\) de \\(U\\) pour lequel \\(P(x)\\) est fausse. Un tel élément est appelé un contre-exemple de \\(\\forall\\ x\\ P(x)\\).\nLa quantification existentielle \\(\\exists\\ x\\ P(x)\\) est vraie s’il existe au moins une valeur \\(x\\) dans l’univers du discours telle que \\(P(x)\\) est vraie. Elle est fausse si \\(P(x)\\) est fausse pour toutes les valeurs possibles de \\(x\\).\nAinsi, pour prouver un énoncé de la forme \\(\\forall\\ x\\ P(x)\\) est vrai, fournir un exemple de \\(x\\) tel que \\(P(x)\\) est vrai ne suffit pas. Il faut montrer que la proposition \\(P(x)\\) est vraie pour toutes les valeurs de \\(x\\), ce qui peut s’avérer particulièrement difficile lorsque \\(U\\) est un ensemble infini. Il en va de même losqu’on veut prouver qu’un énoncé de la forme \\(\\exists\\ x\\ P(x)\\) est faux.\n\n\nTable 2.4: Comment prouver qu’un énoncé quantifié est vrai ou faux quand l’univers du discours \\(U\\) est infini.\n\n\n\n\n\n\n\nPour prouver que\nest vrai\nest faux\n\n\n\n\n\\(\\exists\\ x\\ P(x)\\)\nil suffit de fournir un exemple: un \\(x\\) de \\(U\\) tel que \\(P(x)\\) est vrai.\nil faut fournir un argument général pour montrer que \\(P(x)\\) est faux quel que soit \\(x\\) de \\(U\\).\n\n\n\\(\\forall\\ x\\ P(x)\\)\nil faut fournir un argument général pour montrer que $P(x) est vrai quel que soit \\(x\\) de \\(U\\).\nil suffit de fournir un contre-exemple: un \\(x\\) de \\(U\\) tel que \\(P(x)\\) est faux.\n\n\n\n\n\nExemple 2.11 Si l’univers du discours est l’ensemble des nombres réels et \\[\\begin{align*}\n&P(x)\\ \\text{désigne}\\ x\\geq 0 \\\\\n&Q(x)\\ \\text{désigne}\\ x\\ \\text{est un nombre premier} \\\\\n&R(x)\\ \\text{désigne}\\ 3^x+4^x=5^x \\\\\n&S(x)\\ \\text{désigne}\\ x\\geq 100\n\\end{align*}\\] dites si chacun des énoncés suivants est une proposition vraie, une proposition fausse ou n’est pas une proposition. Donnez un exemple ou un contre-exemple le cas échéant. Dans le cas contraire, indiquez qu’un argument général est requis.\n\n\\(\\forall\\ x\\ P(x)\\)\n\\(\\forall\\ x\\ \\lnot P(x)\\)\n\\(\\forall\\ x\\ P(x^2)\\)\n\\(\\exists\\ x\\ P(x)\\)\n\\(\\exists\\ x\\ \\lnot P(x)\\)\n\\(\\exists\\ x\\ Q(x)\\)\n\\(\\exists\\ x\\ Q(x^2)\\)\n\\(\\forall\\ x\\ R(x)\\)\n\\(P(x)\\)\n\\(\\forall\\ x\\ (S(x)\\rightarrow P(x))\\)\n\\((\\forall\\ x\\ P(x)) \\rightarrow (\\forall\\ x\\ S(x))\\)\n\\(\\forall\\ x\\ S(x+100)\\)\n\\(\\forall\\ x\\ S(x^2+100)\\)\n\n\n\nThéorème 2.1 (Lois de De Morgan pour les quantificateurs) \\[\n\\lnot \\exists\\ x\\ P(x) \\equiv \\forall\\ x\\ \\lnot P(x) \\qquad \\lnot \\forall\\ x\\ P(x) \\equiv \\exists\\ x\\ \\lnot P(x)\n\\]\n\n\nExemple 2.12 Si l’univers du discours est l’ensemble des étudiants du programme Sciences Informatique et Mathématique (ScIM) et \\(M(x)\\) désigne l’énoncé l’étudiant \\(x\\) peut modifier les fichiers du répertoire \\(U\\), traduisez clairement les propositions suivantes à l’aide des quantificateurs.\n\nTous les étudiants de ScIM peuvent modifier les fichiers du répertoire \\(U\\).\nIl est faux que tous les étudiants de ScIM peuvent modifier les fichiers du répertoire \\(U\\).\nAu moins un étudiant de ScIM peut modifier les fichiers du répertoire \\(U\\).\nIl est faux qu’au moins un étudiant de ScIM peut modifier les fichiers du répertoire \\(U\\).\nAucun étudiant de ScIM ne peut modifier les fichiers du répertoire \\(U\\).\nAu moins un étudiant de ScIM ne peut pas modifier les fichiers du répertoire \\(U\\).\n\nDe plus, déterminez les propositions ci-dessus qui sont équivalentes.\n\n\nExemple 2.13 Si l’univers du discours est l’ensemble des billes contenues dans un bol, et si\n\n\\(G(x)\\) désigne la bille \\(x\\) est grosse\n\\(J(x)\\) désigne la bille \\(x\\) est jaune\n\\(R(x)\\) désigne la bille \\(x\\) est rouge\n\\(B(x)\\) désigne la bille \\(x\\) est bleue\n\ntraduisez clairement les propositions suivantes en prenant soin de bien formuler les phrases.\n\n\\(\\forall\\ x\\ (R(x) \\vee J(x))\\)\n\\((\\forall\\ x\\ R(x)) \\vee (\\forall\\ x\\ J(x))\\)\nLes propositions a. et b. sont-elles équivalentes?\n\\(\\exists\\ x\\ B(x)\\)\n\\(\\lnot(\\exists\\ x\\ B(x))\\)\nUtilisez le quantificateur universel \\(\\forall\\) pour écrire une proposition équivalente à la précédente.\n\\(\\lnot(\\forall\\ x\\ R(x))\\)\nUtilisez le quantificateur existentiel \\(\\exists\\) pour écrire une proposition équivalente à la précédente.\n\\(\\forall\\ x\\ (G(x) \\rightarrow B(x))\\)\n\\(\\exists\\ x\\ (G(x) \\wedge B(x))\\)\n\\((\\exists\\ x\\ G(x)) \\wedge (\\exists\\ x\\ B(x))\\)\nLes deux propositions précédentes sont-elles équivalentes?\nLes deux propositions suivantes sont-elles équivalentes? \\[\n(\\exists\\ x\\ R(x)) \\vee (\\exists\\ x\\ J(x)) \\qquad \\text{et} \\qquad \\exists\\ x\\ (R(x) \\vee J(x))\n\\]\nLes deux propositions suivantes sont-elles équivalentes? \\[\n(\\forall\\ x\\ R(x)) \\wedge (\\forall\\ x\\ G(x)) \\qquad \\text{et} \\qquad \\forall\\ x\\ (R(x) \\wedge G(x))\n\\]"
  },
  {
    "objectID": "logique.html#opérations-bit-à-bit",
    "href": "logique.html#opérations-bit-à-bit",
    "title": "2  Logique",
    "section": "2.4 Opérations bit à bit",
    "text": "2.4 Opérations bit à bit"
  },
  {
    "objectID": "logique.html#problèmes-de-logique",
    "href": "logique.html#problèmes-de-logique",
    "title": "2  Logique",
    "section": "2.5 Problèmes de logique",
    "text": "2.5 Problèmes de logique\nLes problèmes suivants se déroulent sur une île imaginaire où tous les habitants sont soit des chevaliers, qui disent toujours la vérité, soit des fripons, qui mentent toujours. Ces énigmes implique un visiteur qui rencontre un petit groupe d’habitants de l’île. La plupart du temps, le but du visiteur est de déduire les types des habitants à partir de leurs énoncés.\nVoici un exemple type de problème possible.\n\n\n\n\n\n\nDéduisez!\n\n\n\nEn vous promenant sur l’île, vous rencontrez trois habitants gardant un pont. Pour passer, vous devez déduire le type de chaque habitant. Chaque individu dit un seul énoncé:\n\nIndividu A: Si je suis un fripon, alors il y a exactement deux chevaliers ici.\nIndividu B: L’individu A ment.\nIndividu C: Soit nous sommes tous des fripons ou alors au moins l’un d’entre nous est un chevalier.\n\nQuels sont les types des trois individus?\n\n\n\nStratégies\nVoici quelques stratégies que vous pouvez utiliser pour résoudre ce genre de problème:\n\nCommencez en supposant qu’un individu est d’un certain type. Soyez stratégique avec votre supposition, tentez de résoudre un énoncé ET.\n\nSi un individu dit ET, supposez qu’il est un chevalier;\nSi un individu dit OU, supposez qu’il est un fripon;\nSi un individu dit SI/ALORS, supposez qu’il est un fripon;\nSi un individu dit SI ET SEULEMENT SI, attendez de connaître la valeur de vérité de leur énoncé avant de faire une supposition.\n\nLorsqu’un individu est un chevalier, vous pouvez continuer leur énoncé.\nLorsqu’un individu est un fripon, vous pouvez continuer la négation de leur énoncé.\n\nPartie 1 ET Partie 2 \\(\\rightarrow\\) NON Partie 1 OU NON Partie 2\nPartie 1 OU Partie 2 \\(\\rightarrow\\) NON Partie 1 ET NON Partie 2\nSI Partie 1, alors Partie 2 \\(\\rightarrow\\) Partie 1 ET NON Partie 2\n\nSoyez prudents avec les si et seulement si\n\nLorsqu’un si et seulement si est VRAI, alors les deux parties ont la même valeur de vérité.\nLorsqu’un si et seulement si est FAUX, alors les deux parties ont des valeurs de vérités différentes.\n\nLorsque vous avez prouvé l’identité d’un individu, vous pouvez utiliser cette information partout dans le reste de l’énigme.\nSi vous avez suffisament d’information pour confirmer que l’énoncé d’un individu est VRAI, alors ils doivent être un chevalier.\nSi vous avez suffisament d’information pour confirmer que l’énoncé d’un individu est FAUX, alors ils doivent être un fripon.\n\n\n\n2.5.1 Trois énoncés différents\nNous pouvons, dans la plupart des problèmes, regrouper les énoncés des habitants de l’île en trois formes distinctes.\n\n2.5.1.1 Accusations et affirmations\nDans une accusation, un habitant A dit par exemple B est un fripon ou un énoncé équivalent comme B ment toujours. Dans une affirmation, l’habitant A dit par exemple B est un chevalier ou alors B dit toujours la vérité.\n\nExemple 2.14 Que pouvez-vous conclure si A et B sont reliés par une accusation?\n\n\nExemple 2.15 Que pouvez-vous conclure si A et B sont reliés par une affirmation?\n\n\n\n2.5.1.2 Conjonctions de fripons\nUn exemple de conjonction de fripons est lorsque A dit que B est un chevalier ou je suis un fripon, ou alors C est un fripon et je suis un fripon\n\nExemple 2.16 Que pouvez-vous conclure si A et B sont reliés par ou je suis un fripon?\n\n\nExemple 2.17 Que pouvez-vous conclure si A et B sont reliés par et je suis un fripon?\n\n\n\n2.5.1.3 Énoncés de différences ou de similarités\nParfois un habitant A dira B est de mon type ou peut-être C n’est pas de mon type.\n\nExemple 2.18 Que pouvez-vous conclure si A dit que B est de son type?\n\n\nExemple 2.19 Que pouvez-vous conclure si A dit que C n’est pas de son type?\n\nIl est intéressant de comparer ces énoncés avec ceux d’accusations et d’affirmations. Ces deux types d’énoncés sont réciproques en quelque sorte. Lorsqu’un habitant dit directement de quel type est un autre habitant (dans une accusation ou une affirmation), tout ce qu’on apprend c’est que la source et la cible sont similaires ou différents, sans apprendre leur type. Par contre, lorsqu’un habitant dit un énoncé par rapport aux similitudes ou aux différences, nous apprenons exactement de quel type la cible est, sans apprendre si elle est similaire ou différente de la source.\n\nExemple 2.20 Vous rencontrez trois habitants de l’île.\n\nA dit: B ne ment jamais.\nA dit: C est un chevalier ou je suis un fripon.\n\n\n\nExemple 2.21 Vous rencontrez trois habitants de l’île.\n\nA dit: B ment toujours.\nB dit: A n’est pas de mon type."
  },
  {
    "objectID": "ensembles.html#notions-de-base-sur-les-ensembles",
    "href": "ensembles.html#notions-de-base-sur-les-ensembles",
    "title": "3  Théorie des ensembles",
    "section": "3.1 Notions de base sur les ensembles",
    "text": "3.1 Notions de base sur les ensembles\n\nDéfinition 3.1 (Ensemble, élément) Un ensemble est un collection non ordonnée d’objets. Les objets sont appelés éléments de l’ensemble et on dit qu’ils appartiennent à l’ensemble.\nNotation : \\(x\\in F\\) signifie que \\(x\\) est un élément de l’ensemble \\(F\\). On dit aussi que \\(x\\) appartient à l’ensemble \\(F\\).\n\n\nDéfinition 3.2 (Ensemble fini ou infini, cardinalité) Soit \\(A\\) un ensemble composé de \\(n\\) éléments distincts. On dit que \\(A\\) est un ensemble fini de cardinalité \\(n\\) et on note \\(|A|=n\\). Un ensemble est dit infini s’il n’est pas fini.\n\n\nExemple 3.1 Soit l’ensemble \\(F=\\set{2,\\pi,7}\\). Utilisez les symboles introduits pour traduire les énoncés suivants: l’ensemble \\(F\\) contient 3 éléments, \\(\\pi\\) appartient à \\(F\\), 5 n’appartient pas à \\(F\\).\n\nOn peut décrire un ensemble en extension (on énumère ses éléments que l’on place entre accolades) \\[\nA=\\set{5,7,9,11} \\qquad B=\\set{1,8,27,64}\n\\] ou en compréhension, comme ceci: \\[\nA=\\set{x\\in\\mathbb{N}\\mid (x\\ \\text{est impair}) \\wedge (5\\leq x \\leq 11)} \\qquad\nB=\\set{x\\in\\mathbb{N}\\mid (x \\leq 64) \\wedge (\\exists\\ y\\in \\mathbb{N},\\ y^3=x)}\n\\]\nPour créer un ensemble dans Python, nous allons utiliser une paire d’accolades { } et placer les différents éléments de notre ensemble entre ces accolades en les séparant avec une virgule. De plus, nous pouvons vérifier si un élément appartient à l’ensemble en utilisant la commande in.\n\nA={-2,0,1,4}\nprint(A, 1 in A, 5 in A)\n\n{0, 1, 4, -2} True False\n\n\nPour calculer la cardinalité d’un ensemble dans Python, vous utilisez la fonction len(). En Python, il faut être prudent si on souhaite utiliser l’ensemble vide, \\(\\emptyset\\). Si vous utilisez {} pour décrire l’ensemble vide, Python va plutôt l’interpréter comme un dictionnaire vide. Vous devez plutôt utiliser la fonction set().\n\nA = {2,3,5,8}\nB = set()\nC = {0}\nprint(len(A), len(B), len(C))\n\n4 0 1"
  },
  {
    "objectID": "ensembles.html#ensembles-de-nombres-mathbbn-mathbbz-mathbbq-mathbbr",
    "href": "ensembles.html#ensembles-de-nombres-mathbbn-mathbbz-mathbbq-mathbbr",
    "title": "3  Théorie des ensembles",
    "section": "3.2 Ensembles de nombres \\(\\mathbb{N}\\), \\(\\mathbb{Z}\\), \\(\\mathbb{Q}\\), \\(\\mathbb{R}\\)",
    "text": "3.2 Ensembles de nombres \\(\\mathbb{N}\\), \\(\\mathbb{Z}\\), \\(\\mathbb{Q}\\), \\(\\mathbb{R}\\)\nNous détaillerons dans la Table 3.1, les ensembles de nombres les plus communs.\n\n\nTable 3.1: Ensembles de nombres usuels.\n\n\n\n\n\n\nEnsemble\nDescription\n\n\n\n\n\\(\\emptyset = \\set{\\phantom{1}}\\)\nEnsemble vide (ne contient aucun élément \\(\\mid\\emptyset\\mid=0\\))\n\n\n\\(\\mathbb{N}=\\set{0,1,2,3,\\ldots}\\)\nEnsemble des nombres naturels\n\n\n\\(\\mathbb{N^*}=\\set{1,2,3,\\ldots}\\)\nEnsemble des nombres naturels strictement positifs\n\n\n\\(\\mathbb{Z}=\\set{\\ldots,-2,-1,0,1,2,\\ldots}\\)\nEnsemble des nombres entiers\n\n\n\\(\\mathbb{Z^*}=\\set{\\ldots,-2,-1,1,2,\\ldots}\\)\nEnsemble des entiers non nuls\n\n\n\\(\\mathbb{Q}=\\set{\\frac{p}{q}\\mid p\\in\\mathbb{Z},q\\in\\mathbb{Z}\\ \\text{et}\\ q\\neq 0}\\)\nEnsemble des nombres rationnels\n\n\n\\(\\mathbb{R}\\)\nEnsemble des nombres réels\n\n\n\\(\\mathbb{R^+}=\\set{x\\in\\mathbb{R}\\mid x\\geq 0}\\)\nEnsemble des nombres réels positifs\n\n\n\\(\\mathbb{C}=\\set{a+bi\\mid a\\in \\mathbb{R}\\ \\text{et}\\ b\\in\\mathbb{R}}\\) avec \\(i^2=-1\\)\nEnsemble des nombres complexes\n\n\n\n\n\nExemple 3.2 Établissez un lien entre les ensembles décrits par compréhension aux parties a. à f. avec le même ensemble décrit par extension aux parties 1 à 6.\n\n\\(\\set{x\\in\\mathbb{Z}\\mid x^2=1}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid x^3=1}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid |x|\\leq 2}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid x^2 \\leq 4}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid x<|x|}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid (x+1)^2=x^2+2x+1}\\)\n\n\n\\(\\set{-1,0,1}\\)\n\\(\\set{\\ldots,-3,-2,-1,0,1,2,3,\\ldots}\\)\n\\(\\set{1}\\)\n\\(\\set{\\ldots,-3,-2,-1}\\)\n\\(\\set{-1,1}\\)\n\\(\\set{-2,-1,0,1,2}\\)\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’il y a trop d’éléments dans un ensemble pour être en mesure de tous les écrire, nous utilisons souvent les trois-points (\\(\\ldots\\)) lorsque la suite d’éléments est claire. Par exemple, nous avons: \\[\n\\mathbb{Z}=\\set{\\ldots,-3,-2,-1,0,1,2,3,\\ldots}\n\\]\n\n\nEn Python, si vous avez un ensemble décrit par compréhension, il est particulièrement facile de le créer avec une compréhension de liste. L’idée est simple: simplifier le code pour le rendre plus lisible et donc plus rapide à écrire et plus simple à maintenir. La syntaxe est la suivante:\nnew_list = [function(item) for item in list if condition(item)]\nnew_list = {function(item) for item in list if condition(item)}\nPar exemple, si vous voulez créer l’ensemble \\(\\set{x^3\\mid 0\\leq x < 10}\\), nous pouvons le faire en Python de la manière suivante:\n\nensemble = {x**3 for x in range(10)}\nliste = [x**3 for x in range(10)]\nprint(ensemble, liste)\n\n{0, 1, 64, 512, 8, 343, 216, 729, 27, 125} [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez que dans l’ensemble, les éléments ne sont pas ordonnés, tandis qu’ils le sont dans la liste.\n\n\n\nDéfinition 3.3 (Égalité d’ensembles) Deux ensembles sont dits égaux si et seulement s’ils contiennent exactement les mêmes éléments. \\[\nA=B \\leftrightarrow \\forall\\ x\\ (x\\in A \\leftrightarrow x\\in B)\n\\]\n\n\nExemple 3.3 Les ensembles suivants sont-ils égaux? \\[\\begin{align*}\n\\set{1,3,5} &\\stackrel{?}{=} \\set{3,5,1} \\\\\n\\set{1,3,5} &\\stackrel{?}{=} \\set{\\set{1},\\set{3},\\set{5}}\n\\end{align*}\\]\n\n\nDéfinition 3.4 (Sous-ensemble) L’ensemble \\(A\\) est sous-ensemble de l’ensemble \\(B\\) si et seulement si tous les éléments de \\(A\\) sont aussi des éléments de \\(B\\): \\[\nA \\subseteq B \\leftrightarrow \\forall\\ x\\ (x\\in A \\rightarrow x\\in B)\n\\] L’ensemble \\(A\\) est sous-ensemble strict (ou propre) de l’ensemble \\(B\\) si et seulement si tous les éléments de \\(A\\) sont aussi des éléments de \\(B\\) et \\(A\\) n’est pas égal à \\(B\\): \\[\nA \\subset B \\leftrightarrow A\\subseteq B \\wedge\\ A\\neq B\n\\]\n\n\nExemple 3.4 Convainquez-vous des affirmations suivantes. \\[\\begin{align*}\n\\set{1,2} &\\subseteq \\set{1,2,3,4,5} \\\\\n\\set{1,2} &\\subset \\set{1,2,3,4,5} \\\\\n\\set{2k\\mid k\\in\\mathbb{N}} &= \\set{0,2,4,6,\\ldots}\\subset\\mathbb{N}\n\\end{align*}\\]\n\n\n\nTable 3.2: Notation de la théorie des ensembles.\n\n\n\n\n\n\nNotation\nDescription\n\n\n\n\n\\(\\in\\)\n\\(2\\in\\set{1,2,3}\\) indique que 2 est un élément de l’ensemble \\(\\set{1,2,3}\\).\n\n\n\\(\\not\\in\\)\n\\(4\\not\\in\\set{1,2,3}\\) indique que 4 n’est pas un élément de l’ensemble \\(\\set{1,2,3}\\).\n\n\n\\(\\subseteq\\)\n\\(A\\subseteq B\\) indique que \\(A\\) est un sous-ensemble de \\(B\\): chaque élément de \\(A\\) est aussi un élément de \\(B\\).\n\n\n\\(\\subset\\)\n\\(A\\subset B\\) indique que \\(A\\) est un sous-ensemble propre de \\(B\\): chaque élément de \\(A\\) est aussi un élément de \\(B\\), mais \\(A\\neq B\\).\n\n\n\n\n\nThéorème 3.1 Pour tout ensemble \\(A\\), on a :\n\n\\(\\emptyset\\subseteq A\\)\n\\(A\\subseteq A\\)\n\n\n\nThéorème 3.2 \\(A=B\\) si et seulement si \\(A\\subseteq B\\) et \\(B\\subseteq A\\).\n\nEn Python, nous pouvons utiliser la fonction issubset pour vérifier qu’un ensemble est sous-ensemble d’un autre.\n\nA = {2,4,6,8,10,12}\nB = {4,8,12}\nprint(A.issubset(B), B.issubset(A))\n\nFalse True"
  },
  {
    "objectID": "ensembles.html#produit-cartésien",
    "href": "ensembles.html#produit-cartésien",
    "title": "3  Théorie des ensembles",
    "section": "3.3 Produit cartésien",
    "text": "3.3 Produit cartésien\n\nDéfinition 3.5 (Produit cartésien) Le produit cartésien des ennsembles \\(A\\) et \\(B\\), noté \\(A\\times B\\), est L’ensemble de tous les couples (paires ordonnées) dont le premier élément appartient à \\(A\\) et le second, à \\(B\\): \\[\nA\\times B = \\set{(a,b)\\mid\\ a\\in A\\ \\text{et}\\ b\\in B}\n\\] On généralise cette définition au produit cartésien de \\(n\\) ensembles: \\[\nA_1 \\times A_2 \\times \\ldots \\times A_n = \\set{(a_1,a_2,\\ldots,a_n)\\mid\\ a_1\\in A_1,\\ldots, a_n\\in A_n}\n\\]\n\n\nExemple 3.5 Décrivez en extension les produits cartésiens \\(A\\times B\\) et \\(B\\times A\\), où \\(A=\\set{0,1,2}\\) et \\(B=\\set{a,c}\\).\n\n\nDéfinition 3.6 (Relation) Une relation entre les ensembles \\(A\\) et \\(B\\) est un sous-ensemble du produit cartésien \\(A\\times B\\).\n\n\nExemple 3.6 Soit $A= et $B=. L’ensemble \\[\nR=\\set{(0,a),(1,c),(2,a)}\\subseteq A\\times B\n\\] est une relation de \\(A\\) dans \\(B\\).\n\n\nDéfinition 3.7 L’ensmeble des parties de \\(A\\), noté \\(\\mathcal{P}(A)\\), est l’ensemble de tous les sous-ensembles de \\(A\\). \\[\nB\\in \\mathcal{P}(A) \\leftrightarrow B \\subseteq A\n\\]\n\n\nExemple 3.7 Décrivez \\(\\mathcal{P}(A)\\), l’ensemble des parties de \\(A\\), où \\(A=\\set{0,1,2}\\).\n\n\n\n\n\n\n\n\n\\(k\\)\nSous-ensembles de \\(A\\) ayant \\(k\\) éléments\nNombre de sous-ensembles\n\n\n\n\n0\n\\(\\emptyset\\)\n1\n\n\n1\n\\(\\set{0}\\), \\(\\set{1}\\), \\(\\set{2}\\)\n3\n\n\n2\n\\(\\set{0,1}\\), \\(\\set{0,2}\\), \\(\\set{1,2}\\)\n3\n\n\n3\n\\(\\set{0,1,2}\\)\n1\n\n\n\n\n\nExemple 3.8 Décrivez \\(\\mathcal{P}(A)\\), l’ensemble des parties de \\(A\\), où \\(A=\\set{0,1,2,3}\\).\n\n\n\n\n\n\n\n\n\\(k\\)\nSous-ensembles de \\(A\\) ayant \\(k\\) éléments\nNombre de sous-ensembles\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4"
  },
  {
    "objectID": "ensembles.html#opérations-sur-les-ensembles-cap-cup-oplus--",
    "href": "ensembles.html#opérations-sur-les-ensembles-cap-cup-oplus--",
    "title": "3  Théorie des ensembles",
    "section": "3.4 Opérations sur les ensembles \\(\\cap\\), \\(\\cup\\), \\(\\oplus\\), \\(-\\)",
    "text": "3.4 Opérations sur les ensembles \\(\\cap\\), \\(\\cup\\), \\(\\oplus\\), \\(-\\)\nSoit \\(U\\) l’ensemble universel et \\(A\\) et \\(B\\) des sous-ensembles de \\(U\\). Les opérations suivantes génèrent des sous-ensembles de \\(U\\).\n\n\nTable 3.3: Les diverses opérations sur les ensembles.\n\n\n\n\n\n\nOpération\nForme mathématique\n\n\n\n\nUnion\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\vee\\ x\\in B}\\)\n\n\nIntersection\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\wedge\\ x\\in B}\\)\n\n\nDifférence\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\wedge\\ x\\not\\in B}=A\\setminus B\\)\n\n\nDifférence symétrique\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\oplus\\ x\\in B}\\)\n\n\nComplément\n\\(\\set{x\\in U\\mid\\ x\\not\\in A}=U-A\\)\n\n\n\n\n\n\n\n\n\n\nUnion\n\n\n\n\n\n\n\nIntersection\n\n\n\n\n\n\n\n\n\nDifférence\n\n\n\n\n\n\n\nDifférence symétrique\n\n\n\n\n\n\n\n\n\nComplément\n\n\n\n\n\nVous pouvez effectuer ces opérations dans Python à l’aide des commandes suivantes:\n\n\nTable 3.4: Les opérations sur les ensembles dans Python.\n\n\nOpération\nCommande Python\n\n\n\n\nUnion\nunion\n\n\nIntersection\nintersection\n\n\nDifférence\ndifference\n\n\n\n\n\nA = {-3,-1,2,5}\nB = {-1, 0, 2}\nprint(A.union(B))\n\n{0, 2, 5, -3, -1}\n\n\n\nA = {-3,-1,2,5}\nB = {-1, 0, 2}\nprint(A.intersection(B))\n\n{2, -1}\n\n\n\nA = {-3,-1,2,5}\nB = {-1, 0, 2}\nprint(A.difference(B))\n\n{5, -3}"
  },
  {
    "objectID": "ensembles.html#représentation-de-sous-ensembles-par-trains-de-bits",
    "href": "ensembles.html#représentation-de-sous-ensembles-par-trains-de-bits",
    "title": "3  Théorie des ensembles",
    "section": "3.5 Représentation de sous-ensembles par trains de bits",
    "text": "3.5 Représentation de sous-ensembles par trains de bits"
  },
  {
    "objectID": "ensembles.html#polygones-convexes-avec-des-opérations-sur-les-ensembles",
    "href": "ensembles.html#polygones-convexes-avec-des-opérations-sur-les-ensembles",
    "title": "3  Théorie des ensembles",
    "section": "3.6 Polygones convexes avec des opérations sur les ensembles",
    "text": "3.6 Polygones convexes avec des opérations sur les ensembles"
  },
  {
    "objectID": "fonctions.html#fonctions-plancher-et-plafond",
    "href": "fonctions.html#fonctions-plancher-et-plafond",
    "title": "4  Fonctions",
    "section": "4.1 Fonctions plancher et plafond",
    "text": "4.1 Fonctions plancher et plafond\n\nDéfinition 4.2 (Fonctions plancher et plafond) La fonction plancher associe à tout nombre réel \\(x\\), le plus grand entier \\(n\\) tel que \\(n\\leq x\\). On note \\(\\lfloor x\\rfloor = n\\). La fonction plafond associe à tout nombre réel \\(x\\), le plus petit entier \\(n\\) tel que \\(n\\geq x\\). On note \\(\\lceil x \\rceil = n\\).\n\n\nExemple 4.2 Calculez les fonctions suivantes: \\[\\begin{align*}\n\\left\\lfloor \\frac{1}{3}\\right\\rfloor &= \\\\\n\\left\\lceil \\frac{1}{3}\\right\\rceil &= \\\\\n\\left\\lfloor -9,2\\right\\rfloor &= \\\\\n\\left\\lceil -9,2\\right\\rceil &= \\\\\n\\end{align*}\\]\n\n\nThéorème 4.1 (Propriétés des fonctions plancher et plafond)  \n\n\\(\\lfloor x\\rfloor = n\\) \\(\\leftrightarrow\\) \\(n\\leq x<n+1\\)\n\\(\\lceil x\\rceil = n\\) \\(\\leftrightarrow\\) \\(n-1< x\\leq n\\)\n\\(x-1<\\lfloor x\\rfloor \\leq x \\leq \\lceil x \\rceil < x+1\\)\n\n\nLa Figure 4.1 présente le graphique des fonctions plancher et plafond.\n\n\n\n\n\n\n\nFonction plancher\n\n\n\n\n\n\n\nFonction plafond\n\n\n\n\nFigure 4.1: Les fonctions plancher et plafond.\n\n\nCes deux fonctions sont accessibles dans Python en utilisant la librairie math, sous le nom de floor (fonction plancher) et ceil (fonction plafond).\n\nimport math\n\nprint(\"Résultats de la fonction plafond\")\nprint(math.ceil(1.4))\nprint(math.ceil(5.3))\nprint(math.ceil(-5.3))\nprint(math.ceil(22.6))\nprint(math.ceil(10.0))\n\nprint(\"Résultats de la fonction plancher\")\nprint(math.floor(1.4))\nprint(math.floor(5.3))\nprint(math.floor(-5.3))\nprint(math.floor(22.6))\nprint(math.floor(10.0))\n\nRésultats de la fonction plafond\n2\n6\n-5\n23\n10\nRésultats de la fonction plancher\n1\n5\n-6\n22\n10"
  },
  {
    "objectID": "fonctions.html#fonctions-en-python",
    "href": "fonctions.html#fonctions-en-python",
    "title": "4  Fonctions",
    "section": "4.2 Fonctions en Python",
    "text": "4.2 Fonctions en Python\nDEVRAIT-ON PARLER DE ÇA????\nDICTIONNAIRE, HACHAGE…\n\nExemple 4.3 Fonction de hachage dans Python\nHachage Python\nDictionnary in Python\nA checksum is used to determine if something is the same.\nIf you have download a file, you can never be sure if it got corrupted on the way to your machine. You can use cksum to calculate a checksum (based on CRC-32) of the copy you now have and can then compare it to the checksum the file should have. This is how you check for file integrity.\nA hash function is used to map data to other data of fixed size. A perfect hash function is injective, so there are no collisions. Every input has one fixed output.\nA cryptographic hash function is used for verification. With a cryptographic hash function you should to not be able to compute the original input.\nA very common use case is password hashing. This allows the verification of a password without having to save the password itself. A service provider only saves a hash of a password and is not able to compute the original password. If the database of password hashes gets compromised, an attacker should not be able to compute these passwords as well. This is not the case, because there are strong and weak algorithms for password hashing. You can find more on that on this very site.\nTL;DR:\nChecksums are used to compare two pieces of information to check if two parties have exactly the same thing.\nHashes are used (in cryptography) to verify something, but this time, deliberately only one party has access to the data that has to be verified, while the other party only has access to the hash."
  },
  {
    "objectID": "fonctions.html#injection-surjection-et-bijection",
    "href": "fonctions.html#injection-surjection-et-bijection",
    "title": "4  Fonctions",
    "section": "4.3 Injection, surjection et bijection",
    "text": "4.3 Injection, surjection et bijection\n\nDéfinition 4.3 (Fonction injective, surjective, bijective) Soit \\(f:A\\rightarrow B\\) une fonction. On dit que\n\n\\(f\\) est injective si elle n’associe jamais la même image à deux éléments distincts: \\[\n\\forall\\ a_1 \\in A,\\ \\forall\\ a_2 \\in A,\\ (a_1\\neq a_2) \\rightarrow (f(a_1) \\neq f(a_2))\n\\]\n\\(f\\) est surjective si son image est l’ensemble \\(B\\) au complet, c’est-à-dire si tous les éléments de \\(B\\) sont atteints: \\[\n\\forall\\ b\\in B,\\ \\exists\\ a \\in A,\\ f(a)=b\n\\]\n\\(f\\) est bijective si elle est injective et surjective: \\[\n\\forall\\ b\\in B,\\ \\exists! a\\in A,\\ f(a)=b\n\\]\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSi une fonction n’est pas injective, alors elle ne possède pas d’inverse.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSi une fonction n’est pas surjective, alors elle ne possède pas d’inverse.\n\n\n\nExemple 4.4 On considère un sous-ensemble \\(f\\) du produit cartésien de deux ensembles. Dans chaque cas, tracez son graphe saggital puis déterminez s’il s’agit d’une fonction ou non. De plus, si \\(f\\) est une fonction, déterminez si elle est injective, surjective ou bijective.\nIci, \\(L=\\set{a,b,c,d,e}\\), \\(M=\\set{a,b,c}\\), \\(C=\\set{1,2,3,4}\\) et \\(D=\\set{1,2,3}\\).\n\n\\(f=\\set{(1,a),(2,d),(3,c),(4,e)}\\subseteq C \\times L\\)\n\\(f=\\set{(1,a),(2,a),(3,c),(4,b)}\\subseteq C \\times M\\)\n\\(f=\\set{(1,a),(2,d),(3,c),(4,e),(1,b)}\\subseteq C \\times L\\)\n\\(f=\\set{(1,c),(2,a),(3,a),(4,a)}\\subseteq D \\times M\\)\n\\(f=\\set{(1,a),(2,a),(3,a),(4,a)}\\subseteq C \\times L\\)\n\n\n\nExemple 4.5 La fonction \\(f:\\mathbb{Z}\\times\\mathbb{Z}\\rightarrow \\mathbb{Z}\\) définie par \\(f(x_1,x_2)=x_1+x^2\\) est-elle oui on non injective? Est-elle oui ou non surjective? Est-elle oui ou non bijective?\n\n\n4.3.1 Les dictionnaires dans Python\nLe dictionnaire n’est pas une séquence mais un autre type composite. Ils ressemblent aux listes dans une certaine mesure (ils sont modifiables comme elles), mais les éléments que nous allons y enregistrer ne seront pas disposés dans un ordre immuable. En revanche, nous pourrons accéder à n’importe lequel d’entre eux à l’aide d’un index spécifique que l’on appellera une clé, laquelle pourra être alphabétique, numérique, ou même d’un type composite sous certaines conditions.\n\nExemple 4.6 Dites si le dictionnaire défini ci-dessous est une fonction injective, surjective, ou bijective.\n\njour = {\"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}\ndejeuner = {\"Oeufs\", \"Céréales\", \"Rôties\", \"Gruau\", \"Pâtisserie\", \"Jambon\", \"Crèpes\",\"Saucisses\"}\n\nmydict = {\n    \"Lundi\": \"Oeufs\",\n    \"Mardi\": \"Céréales\",\n    \"Mercredi\": \"Rôties\",\n    \"Jeudi\": \"Gruau\",\n    \"Vendredi\": \"Pâtisserie\",\n    \"Samedi\": \"Jambon\",\n    \"Dimanche\": \"Crèpes\"\n}\n\n\n\nExemple 4.7 Dites si le dictionnaire défini ci-dessous est une fonction injective, surjective, ou bijective.\n\njour = {\"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}\ndejeuner = {\"Oeufs\", \"Céréales\", \"Rôties\", \"Gruau\", \"Pâtisserie\", \"Jambon\", \"Crèpes\",\"Saucisses\"}\n\nmydict = {\n    \"Lundi\": \"Oeufs\",\n    \"Mardi\": \"Oeufs\",\n    \"Mercredi\": \"Rôties\",\n    \"Jeudi\": \"Gruau\",\n    \"Vendredi\": \"Pâtisserie\",\n    \"Samedi\": \"Jambon\",\n    \"Dimanche\": \"Crèpes\"\n}\n\n\n\n\n4.3.2 Fonction de hachage\nUne fonction de hachage est une fonction qui associe des données de taille arbitraire à des valeurs de taille fixe. Les valeurs renvoyées par une fonction de hachage sont appelées valeurs de hachage, codes de hachage, résumés, signatures ou simplement hachages. Les valeurs sont généralement utilisées pour être les indices d’une table de taille raisonnable appelée table de hachage. Le hachage ou adressage de stockage dispersé est donc l’utilisation d’une fonction de hachage pour créer les indices d’une table de hachage.\nLes fonctions de hachage sont utilisées dans les applications de stockage et de récupération de données pour accéder aux données en un temps réduit, en fait quasi-constant. Elles requièrent un espace de stockage à peine plus grand que l’espace total requis pour les données. Ainsi, le hachage est une forme d’accès aux données efficace en termes de calcul et d’espace de stockage.\nL’intérêt des fonctions de hachage repose sur de bonnes propriétés statistiques. En effet, le comportement dans le pire des cas est mauvais, mais il se manifeste avec une probabilité extrêmement faible, en fait négligeable, et le comportement dans le cas moyen est optimal (collision minimale ).\nUne fonction de hachage est typiquement une fonction qui, pour un ensemble de très grande taille (théoriquement infini) et de nature très diversifiée, va renvoyer des résultats aux spécifications précises (en général des chaînes de caractère de taille limitée ou fixe) optimisées pour des applications particulières. Les chaînes permettent d’établir des relations (égalité, égalité probable, non-égalité, ordre…) entre les objets de départ sans accéder directement à ces derniers, en général soit pour des questions d’optimisation (la taille des objets de départ nuit aux performances), soit pour des questions de confidentialité.\nAutrement dit : à 1 fichier (ou à 1 mot) va correspondre une signature unique (le résultat de la fonction de hachage).\n\n\n\n\n\n\nImportant\n\n\n\nDans l’idéal, une fonction de hachage devrait être injective.\n\n\nOn peut trouver le haché d’un élément en Python en utilisant la commande hash. On peut remarquer dans le code ci-dessous que de changer une lettre minuscule en lettre majuscule (le F de fromage) change drastiquement le haché.\n\nphrase1 = \"Maître Corbeau, sur un arbre perché, Tenait en son bec un fromage.\"\nphrase2 = \"Maître Corbeau, sur un arbre perché, Tenait en son bec un Fromage.\"\n\nprint(hex(hash(phrase1)), hex(hash(phrase2)))\n\n-0x2fbb3b70eac01935 -0x6f90b65060bc112a"
  },
  {
    "objectID": "notation_grand_o.html#mesurer-un-temps-de-calcul-avec-une-fonction",
    "href": "notation_grand_o.html#mesurer-un-temps-de-calcul-avec-une-fonction",
    "title": "5  Notation grand O",
    "section": "5.1 Mesurer un temps de calcul avec une fonction",
    "text": "5.1 Mesurer un temps de calcul avec une fonction"
  },
  {
    "objectID": "notation_grand_o.html#notation-grand-o",
    "href": "notation_grand_o.html#notation-grand-o",
    "title": "5  Notation grand O",
    "section": "5.2 Notation grand-O",
    "text": "5.2 Notation grand-O"
  },
  {
    "objectID": "notation_grand_o.html#sommations",
    "href": "notation_grand_o.html#sommations",
    "title": "5  Notation grand O",
    "section": "5.3 Sommations",
    "text": "5.3 Sommations"
  },
  {
    "objectID": "notation_grand_o.html#établir-la-complexité-dun-algorithme",
    "href": "notation_grand_o.html#établir-la-complexité-dun-algorithme",
    "title": "5  Notation grand O",
    "section": "5.4 Établir la complexité d’un algorithme",
    "text": "5.4 Établir la complexité d’un algorithme"
  },
  {
    "objectID": "notation_grand_o.html#calculabilité-et-complexité",
    "href": "notation_grand_o.html#calculabilité-et-complexité",
    "title": "5  Notation grand O",
    "section": "5.5 Calculabilité et complexité",
    "text": "5.5 Calculabilité et complexité"
  },
  {
    "objectID": "notation_grand_o.html#p-vs-np",
    "href": "notation_grand_o.html#p-vs-np",
    "title": "5  Notation grand O",
    "section": "5.6 P vs NP",
    "text": "5.6 P vs NP"
  },
  {
    "objectID": "algorithmes.html#bogo-sort",
    "href": "algorithmes.html#bogo-sort",
    "title": "6  Introduction aux algorithmes",
    "section": "6.1 Bogo sort",
    "text": "6.1 Bogo sort\n\nfrom random import shuffle\nfrom random import seed\nfrom random import randint\n\ndef is_sorted(data) -> bool:\n    \"\"\"Determine whether the data is sorted.\"\"\"\n    return all(a <= b for a, b in zip(data, data[1:]))\n\ndef bogosort(data) -> list:\n    \"\"\"Shuffle data until sorted.\"\"\"\n    N = 0\n    while not is_sorted(data):\n        shuffle(data)\n        N = N + 1\n    return data, N\n\nseed(1234)\nN = 8\ndata = [randint(1,10) for x in range(N)]\nbogosort(data)\n\n([1, 1, 2, 2, 2, 2, 8, 10], 1552)"
  },
  {
    "objectID": "algorithmes.html#exemples-dalgorithmes",
    "href": "algorithmes.html#exemples-dalgorithmes",
    "title": "6  Introduction aux algorithmes",
    "section": "6.2 Exemples d’algorithmes",
    "text": "6.2 Exemples d’algorithmes"
  },
  {
    "objectID": "algorithmes.html#fouille-linéaire",
    "href": "algorithmes.html#fouille-linéaire",
    "title": "6  Introduction aux algorithmes",
    "section": "6.3 Fouille linéaire",
    "text": "6.3 Fouille linéaire"
  },
  {
    "objectID": "algorithmes.html#bubble-sort",
    "href": "algorithmes.html#bubble-sort",
    "title": "6  Introduction aux algorithmes",
    "section": "6.4 Bubble sort",
    "text": "6.4 Bubble sort"
  },
  {
    "objectID": "algorithmes.html#insertion-sort",
    "href": "algorithmes.html#insertion-sort",
    "title": "6  Introduction aux algorithmes",
    "section": "6.5 Insertion sort",
    "text": "6.5 Insertion sort"
  },
  {
    "objectID": "algorithmes.html#binary-search",
    "href": "algorithmes.html#binary-search",
    "title": "6  Introduction aux algorithmes",
    "section": "6.6 Binary search",
    "text": "6.6 Binary search"
  },
  {
    "objectID": "algorithmes.html#heap-sort",
    "href": "algorithmes.html#heap-sort",
    "title": "6  Introduction aux algorithmes",
    "section": "6.7 Heap sort",
    "text": "6.7 Heap sort"
  },
  {
    "objectID": "algorithmes.html#complexité-algorithmique",
    "href": "algorithmes.html#complexité-algorithmique",
    "title": "6  Introduction aux algorithmes",
    "section": "6.8 Complexité algorithmique",
    "text": "6.8 Complexité algorithmique"
  },
  {
    "objectID": "theorie_nombres.html#arithmétique-modulaire",
    "href": "theorie_nombres.html#arithmétique-modulaire",
    "title": "7  Théorie des nombres",
    "section": "7.1 Arithmétique modulaire",
    "text": "7.1 Arithmétique modulaire\n\n7.1.1 Division entière\n\n\n7.1.2 Congruence modulo \\(m\\)"
  },
  {
    "objectID": "theorie_nombres.html#entiers-et-algorithmes",
    "href": "theorie_nombres.html#entiers-et-algorithmes",
    "title": "7  Théorie des nombres",
    "section": "7.2 Entiers et algorithmes",
    "text": "7.2 Entiers et algorithmes\n\n7.2.1 Algorithme d’exponentiation modulaire efficace\n\n\n7.2.2 Nombres premiers et PGCD\n\n\n7.2.3 Algorithme d’Euclide et théorème de Bézout\n\n\n7.2.4 Inverse modulo \\(m\\)\n\n\n7.2.5 Résolution de congruence\n\n\n7.2.6 Petit théorème de Fermat"
  },
  {
    "objectID": "theorie_nombres.html#cryptographie-à-clé-secrète",
    "href": "theorie_nombres.html#cryptographie-à-clé-secrète",
    "title": "7  Théorie des nombres",
    "section": "7.3 Cryptographie à clé secrète",
    "text": "7.3 Cryptographie à clé secrète\n\n7.3.1 Chiffrement par décalage\n\n\n7.3.2 Permutation de l’alphabet\n\n\n7.3.3 Masque jetable\n\n\n7.3.4 Chiffrement affine"
  },
  {
    "objectID": "theorie_nombres.html#cryptographie-à-clé-publique",
    "href": "theorie_nombres.html#cryptographie-à-clé-publique",
    "title": "7  Théorie des nombres",
    "section": "7.4 Cryptographie à clé publique",
    "text": "7.4 Cryptographie à clé publique\n\n7.4.1 Chiffrement RSA"
  },
  {
    "objectID": "preuves.html#méthodes-de-preuve",
    "href": "preuves.html#méthodes-de-preuve",
    "title": "8  Preuves et raisonnement mathématique",
    "section": "8.1 Méthodes de preuve",
    "text": "8.1 Méthodes de preuve\n\n8.1.1 Preuve directe\n\nExemple 8.1 LE PRODUIT DE NOMBRES PAIRS ET IMPAIRS\n\n\nExemple 8.2 RACINE DE NOMBRES PAIRS\n\n\nExemple 8.3 PREUVE QUE \\(n^2\\) EST PAIR\n\n\nExemple 8.4 Soit \\(a\\), \\(b\\) et \\(c\\) des entiers. Si \\(a|b\\) et \\(b|c\\) alors \\(a|c\\).\n\n\n\n8.1.2 Preuve indirecte (par contraposée)\n\nExemple 8.5 Montrez que si \\(n^2\\) est pair alors \\(n\\) est pair.\n\n\nExemple 8.6 Montrez que si \\(a+b\\) est impair, alors \\(a\\) est impair ou \\(b\\) est impair.\n\n\nExemple 8.7 Soit \\(p\\) un nombre premier. Si \\(p\\neq 2\\) alors \\(p\\) est impair.\n\n\n\n8.1.3 Preuve par contradiction\n\nExemple 8.8 EXISTE-T-IL UN PLUS PETIT NOMBRE RATIONNEL POSITIF?\n\n\nExemple 8.9 PREUVE QUE \\(\\sqrt{2}\\) EST IRRATIONNEL\n\n\nExemple 8.10 PREUVE QUE QU’IL EXISTE UNE INFINITÉ DE NOMBRES PREMIERS\n\n\nExemple 8.11 Il n’existe pas d’entiers \\(x\\) et \\(y\\) tels que \\(x^2=4y+2\\).\n\n\n\n8.1.4 Principe des tiroirs de Dirichlet\n\nExemple 8.12 (Fonction de hachage) Une fonction de hachage est une fonction qui transforme une suite de bits de longueur arbitraire en une chaîne de longueur fixe. Du fait qu’il y a plus de chaînes possibles en entrée qu’en sortie découle par le principe des tiroirs l’existence de collisions : plusieurs chaînes distinctes ont le même haché. Rendre ces collisions difficiles à déterminer efficacement est un enjeu important en cryptographie."
  },
  {
    "objectID": "preuves.html#principe-de-linduction",
    "href": "preuves.html#principe-de-linduction",
    "title": "8  Preuves et raisonnement mathématique",
    "section": "8.2 Principe de l’induction",
    "text": "8.2 Principe de l’induction\n\n8.2.1 Preuve par récurrence\n\nExemple 8.13 PREUVE QUE \\(1+2+3+\\ldots +n=\\frac{n(n+1)}{2}\\)\n\n\nExemple 8.14 PREUVE QUE \\(n<2^n\\)\n\n\nExemple 8.15 PREUVE QUE 6 EST UN DIVISEUR DE \\(7^n-1\\)\n\n\nExemple 8.16 MONTRER QUE NOUS POUVONS UTILISER DES T-GONES POUR REMPLIR UNE GRILLE \\(2^n \\times 2^n\\)\n\n\nExemple 8.17 MONTRER QUE LA FACTORIELLE CROÎT PLUS RAPIDEMENT QUE L’EXPONENTIELLE\n\n\n\n8.2.2 Algorithmes récursifs\n\n8.2.2.1 Fonctions récursives\n\n\n8.2.2.2 Algorithmes de type diviser pour régner"
  },
  {
    "objectID": "denombrement.html#notions-de-base",
    "href": "denombrement.html#notions-de-base",
    "title": "9  Dénombrement",
    "section": "9.1 Notions de base",
    "text": "9.1 Notions de base"
  },
  {
    "objectID": "denombrement.html#principe-des-nids-de-pigeon-principe-des-tiroirs-de-dirichlet",
    "href": "denombrement.html#principe-des-nids-de-pigeon-principe-des-tiroirs-de-dirichlet",
    "title": "9  Dénombrement",
    "section": "9.2 Principe des nids de pigeon (principe des tiroirs de Dirichlet)",
    "text": "9.2 Principe des nids de pigeon (principe des tiroirs de Dirichlet)"
  },
  {
    "objectID": "denombrement.html#permutations-et-combinaisons",
    "href": "denombrement.html#permutations-et-combinaisons",
    "title": "9  Dénombrement",
    "section": "9.3 Permutations et combinaisons",
    "text": "9.3 Permutations et combinaisons"
  },
  {
    "objectID": "denombrement.html#relations-de-récurrence-et-dénombrement",
    "href": "denombrement.html#relations-de-récurrence-et-dénombrement",
    "title": "9  Dénombrement",
    "section": "9.4 Relations de récurrence et dénombrement",
    "text": "9.4 Relations de récurrence et dénombrement"
  },
  {
    "objectID": "graphes.html#terminologie-et-types-de-graphes",
    "href": "graphes.html#terminologie-et-types-de-graphes",
    "title": "10  Graphes",
    "section": "10.1 Terminologie et types de graphes",
    "text": "10.1 Terminologie et types de graphes"
  },
  {
    "objectID": "graphes.html#représentation-des-graphes",
    "href": "graphes.html#représentation-des-graphes",
    "title": "10  Graphes",
    "section": "10.2 Représentation des graphes",
    "text": "10.2 Représentation des graphes\n\n10.2.1 Représentation par listes d’adjacence\n\n\n10.2.2 Représentation par matrice d’adjacence"
  },
  {
    "objectID": "graphes.html#chemins-dans-un-graphe",
    "href": "graphes.html#chemins-dans-un-graphe",
    "title": "10  Graphes",
    "section": "10.3 Chemins dans un graphe",
    "text": "10.3 Chemins dans un graphe\n\n10.3.1 Chemins, circuits, cycles\n\n\n10.3.2 Dénombrement de chemins\n\n\n10.3.3 Chemins et circuits eulériens\n\n\n10.3.4 Chemins et circuits hamiltoniens"
  },
  {
    "objectID": "graphes.html#problème-du-plus-court-chemin",
    "href": "graphes.html#problème-du-plus-court-chemin",
    "title": "10  Graphes",
    "section": "10.4 Problème du plus court chemin",
    "text": "10.4 Problème du plus court chemin"
  },
  {
    "objectID": "arbres.html#introduction-aux-arbres",
    "href": "arbres.html#introduction-aux-arbres",
    "title": "11  Arbres",
    "section": "11.1 Introduction aux arbres",
    "text": "11.1 Introduction aux arbres"
  },
  {
    "objectID": "arbres.html#applications-des-arbres",
    "href": "arbres.html#applications-des-arbres",
    "title": "11  Arbres",
    "section": "11.2 Applications des arbres",
    "text": "11.2 Applications des arbres"
  },
  {
    "objectID": "arbres.html#parcours-dun-arbre",
    "href": "arbres.html#parcours-dun-arbre",
    "title": "11  Arbres",
    "section": "11.3 Parcours d’un arbre",
    "text": "11.3 Parcours d’un arbre"
  },
  {
    "objectID": "arbres.html#arbres-et-tri",
    "href": "arbres.html#arbres-et-tri",
    "title": "11  Arbres",
    "section": "11.4 Arbres et tri",
    "text": "11.4 Arbres et tri"
  },
  {
    "objectID": "arbres.html#arbres-et-recouvrement",
    "href": "arbres.html#arbres-et-recouvrement",
    "title": "11  Arbres",
    "section": "11.5 Arbres et recouvrement",
    "text": "11.5 Arbres et recouvrement"
  },
  {
    "objectID": "arbres.html#arbres-générateurs-de-coût-minimal",
    "href": "arbres.html#arbres-générateurs-de-coût-minimal",
    "title": "11  Arbres",
    "section": "11.6 Arbres générateurs de coût minimal",
    "text": "11.6 Arbres générateurs de coût minimal"
  }
]