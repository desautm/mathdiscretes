[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mathématiques discrètes",
    "section": "",
    "text": "Préface\nCe document est un livre Quarto.\nPour en apprendre davantage sur les livres Quarto, visitez https://quarto.org/docs/books."
  },
  {
    "objectID": "systeme_numeration_v2.html#système-décimal",
    "href": "systeme_numeration_v2.html#système-décimal",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.1 Système décimal",
    "text": "1.1 Système décimal\nIl s’agit du système de numération le plus utilisé dans notre société. On peut le résumer avec les trois règles suivantes.\n\nBase = 10\nSymboles ordonnés qu’on nomme les chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.\nLe poids des symboles est donné par 10position\n\nAinsi, l’écriture “197 281” signifie: \\[\n197\\ 281 = 1\\cdot 10^5 + 9\\cdot 10^4 + 7\\cdot 10^3 + 2\\cdot 10^2 + 8\\cdot 10^1 +1 \\cdot 10^0\n\\]\n\nExemple 1.1 Représentez le nombre 3482 sous une forme de numération positionnelle."
  },
  {
    "objectID": "systeme_numeration_v2.html#système-binaire",
    "href": "systeme_numeration_v2.html#système-binaire",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.2 Système binaire",
    "text": "1.2 Système binaire\nCe concept est essentiel en informatique, puisque les processeurs des ordinateurs sont composés de transistors ne gérant que deux états chacun (0 ou 1). Un calcul informatique n’est donc qu’une suite d’opérations sur des paquets de 0 et de 1, appelés bits.\n\nBase = 2\nSymboles ordonnés qu’on nomme les bits: 0, 1\nLe poids des symboles est donné par 2position\n\n\n\n\n\n\n\nImportant\n\n\n\nEn base 2, le chiffre 2 n’existe pas (c’est un nombre); tout comme le chiffre 10 n’existe pas en base 10 (c’est un nombre).\n\n\n\n\n\n\n\n\nNombres binaires en Python\n\n\n\nPour indiquer qu’un nombre est en binaire dans Python, il faut le faire précéder par 0b.\nPour convertir un nombre en binaire, on utilise la command bin.\n\n\n\nExemple 1.2 Quels sont les nombres qui, dans la base deux, succèdent à (0)2?\n\ndepart = 0b0\nfor i in range(6):\n    depart = depart + 1\n    print(bin(depart))\n\n0b1\n0b10\n0b11\n0b100\n0b101\n0b110\n\n\n\n\nExemple 1.3 Quels sont les nombres qui, dans la base deux, succèdent à (1110)2?\n\ndepart = 0b1110\nfor i in range(6):\n    depart = depart + 1\n    print(bin(depart))\n\n0b1111\n0b10000\n0b10001\n0b10010\n0b10011\n0b10100\n\n\n\n\nExemple 1.4 Convertissez le nombre (11001)2 en décimal.\n\n\nExemple 1.5 Convertissez les nombres suivants en décimal.\n\n(110)2 =\n(101101)2 =\n(0,1011)2 =\n(110,101)2 ="
  },
  {
    "objectID": "systeme_numeration_v2.html#système-octal",
    "href": "systeme_numeration_v2.html#système-octal",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.3 Système octal",
    "text": "1.3 Système octal\nLe système de numération octal est le système de numération de base 8, et utilise les chiffres de 0 à 7. D’après l’ouvrage de Donald Knuth’s, The Art of Computer Programming, il fut inventé par le roi Charles XII de Suède.\n\nBase = 8\nSymboles ordonnés qu’on nomme les chiffres: 0, 1, 2, 3, 4, 5, 6, 7\nLe poids des symboles est donné par 8position\n\n\n\n\n\n\n\nNombres octaux en Python\n\n\n\nPour indiquer qu’un nombre est en octal dans Python, il faut le faire précéder par 0o.\nPour convertir un nombre en octal, on utilise la commande oct.\n\n\n\nExemple 1.6 Quels sont les nombres qui, dans la base 8, succèdent à (65)8?\n\ndepart = 0o65\nfor i in range(12):\n    depart = depart + 1\n    print(oct(depart))\n\n0o66\n0o67\n0o70\n0o71\n0o72\n0o73\n0o74\n0o75\n0o76\n0o77\n0o100\n0o101"
  },
  {
    "objectID": "systeme_numeration_v2.html#système-hexadécimal",
    "href": "systeme_numeration_v2.html#système-hexadécimal",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.4 Système hexadécimal",
    "text": "1.4 Système hexadécimal\nLe système hexadécimal est utilisé notamment en électronique numérique et en informatique car il est particulièrement commode et permet un compromis entre le code binaire des machines et une base de numération pratique à utiliser pour les ingénieurs. En effet, chaque chiffre hexadécimal correspond exactement à quatre chiffres binaires (ou bits), rendant les conversions très simples et fournissant une écriture plus compacte. L’hexadécimal a été utilisé la première fois en 1956 par les ingénieurs de l’ordinateur Bendix G-15.\n\nBase = 16\nSymboles ordonnés qu’on nomme les chiffres: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\nLe poids des symboles est donné par 16position\n\nOn remarque qu’en base 16, les dix chiffres de 0 à 9 ne suffisent pas. Il faut donc se doter de 6 symboles additionnels. On utilise les lettres de A à F avec la signification suivante:\n\\[\n(A)_{16}=(10)_{10}, \\quad (B)_{16}=(11)_{10}, \\quad (C)_{16}=(12)_{10}\n\\]\n\\[\n\\quad (D)_{16}=(13)_{10} \\quad (E)_{16}=(14)_{10}, \\quad (F)_{16}=(15)_{10}\n\\]\n\n\n\n\n\n\nNombres hexadécimaux en Python\n\n\n\nPour indiquer qu’un nombre est en hexadécimal dans Python, il faut le faire précéder par 0x.\nPour convertir un nombre en hexadécimal, on utilise la commande hex.\n\n\n\nExemple 1.7 Quels sont les nombres qui, dans la base 16, succèdent à (AAA)16?\n\ndepart = 0xAAA\nfor i in range(12):\n    depart = depart + 1\n    print(hex(depart))\n\n0xaab\n0xaac\n0xaad\n0xaae\n0xaaf\n0xab0\n0xab1\n0xab2\n0xab3\n0xab4\n0xab5\n0xab6\n\n\n\n\nExemple 1.8 Trouvez la représentation en base 10 de:\n\n(AB0)16\n(214,EA)16\n\n\n\n\n\n\n\n\nImportant\n\n\n\nPour convertir un nombre de la base \\(b\\) vers la base 10 (décimal), on trouve sa représentation polynomiale.\n\n\n\n\n\n\n\n\nConversion des nombres entiers vers décimal en Python\n\n\n\nPour convertir un nombre entier \\(nb\\) représenté dans la base \\(b\\) en Python en décimal, on utilise la commande int(nb, b). Le nombre entier \\(nb\\) doit être représenté comme une chaîne de caractères (string).\nPar exemple, si vous avez le nombre hexadécimal \\(A0F\\), vous le convertissez de la manière suivante:\n\nint('A0F', 16)\n\n2575"
  },
  {
    "objectID": "systeme_numeration_v2.html#division-entière",
    "href": "systeme_numeration_v2.html#division-entière",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.5 Division entière",
    "text": "1.5 Division entière\n\nDéfinition 1.3 (Divisibilité) Si \\(a\\in\\mathbb{Z}\\), \\(b\\in\\mathbb{Z}\\) et \\(a\\neq 0\\), on dit que \\(a\\) divise \\(b\\) s’il existe un entier \\(c\\) tel que \\(b=ac\\). L’entier \\(a\\) est alors appelé facteur de \\(b\\).\nSi \\(a\\) divise \\(b\\), nous le notons \\(a \\mid b\\).\n\n\nThéorème 1.1 (Divisibilité) Soit \\(a\\), \\(b\\) et \\(c\\) des nombres entiers quelconques, avec \\(a\\neq 0\\).\n\nSi \\(a\\mid b\\) et \\(a\\mid c\\) alors \\(a\\mid(b+c)\\) et \\(a\\mid (b-c)\\).\nSi \\(a\\mid b\\) alors \\(a\\mid (bc)\\).\nSi \\(a\\mid b\\) et \\(b\\mid c\\) alors \\(a\\mid c\\).\n\n\n\nExemple 1.9 Vrai ou faux? Justifiez en invoquant une définition, un théorème, en donnant une preuve ou un contre-exemple.\n\n\\(7\\mid 10\\)\n\\(-5\\mid 10\\)\n\\(100\\mid 10\\)\n\\(5\\mid -10\\)\n\n\n\nThéorème 1.2 Soit \\(a\\) et \\(d\\) des entiers, avec \\(d&gt;0\\). Il existe une seule paire d’entiers \\(q\\) et \\(r\\) satisfaisant \\[\n0\\leq r&lt;d \\quad \\text{et} \\quad a=dq+r\n\\]\n\n\nDéfinition 1.4 (Diviseur, dividende, quotient, reste) Considérons \\(a\\) et \\(d\\) des entiers, avec \\(d&gt;0\\). Le Théorème 1.2 stipule qu’il existe une seule paire d’entiers \\(q\\) et \\(r\\) satisfaisant \\[\na=dq+r \\quad \\text{et} \\quad 0\\leq r&lt;d\n\\]\nPar exemple, si \\(a=17\\) et \\(d=3\\), on a \\[\n17=3\\cdot 5+2 \\quad \\text{et} \\quad 0\\leq 2&lt;3\n\\]\n\nL’entier \\(d=3\\) est appelé diviseur.\nL’entier \\(a=17\\) est appelé le dividende.\nL’entier \\(q=5\\) est appeléle quotient (notation: \\(q=a\\ \\mathbf{div}\\ d\\)).\nL’entier \\(r=2\\) est appelé le reste."
  },
  {
    "objectID": "systeme_numeration_v2.html#conversions-de-la-base-10-vers-une-base-b",
    "href": "systeme_numeration_v2.html#conversions-de-la-base-10-vers-une-base-b",
    "title": "1  Systèmes de numération positionnelle",
    "section": "1.6 Conversions de la base 10 vers une base \\(b\\)",
    "text": "1.6 Conversions de la base 10 vers une base \\(b\\)\nPour convertir un nombre entier de la base 10 vers une base \\(b\\), il faut effectuer de façon successive des divisions en utilisant la Définition 1.4. Les restes des divisions successives correspondent aux coefficients de la représentation polynomiale (lire de base en haut).\n\n1.6.1 Conversions vers binaire\n\nExemple 1.10 Convertissez les nombres suivants en binaire.\n\n115\n71\n\n\nNous pouvons utiliser la commande bin de Python pour convertir des entiers décimaux en binaire.\n\nprint(bin(115))\nprint(bin(71))\n\n0b1110011\n0b1000111\n\n\nPour convertir un nombre fractionnaire en binaire, il suffit de multiplier (plutôt que de diviser) la partie fractionnaire en notant les parties entières et fractionnaires obtenues. Il faut ensuite répéter ces étapes avec la nouvelle partie fractionnaire et poursuivre le processus jusqu’à ce que la partie fractionnaire soit nulle. Les parties entières des résultats de ces produits correspondent aux coefficients de la représentation polynomiale (lire de haut en bas).\n\nExemple 1.11 Convertissez les nombres suivants en binaire.\n\n(0,8125)10\n(0,15)10\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa conversion en binaire ou en n’importe quelle base ne donne pas toujours une suite finie. Si c’est un nombre rationnel, la conversion donnera toujours une suite finie ou périodique.\n\n\n\nExemple 1.12 Convertissez en binaire les nombres suivants, en ne conservant que 6 chiffres pour la partie fractionnaire, au besoin.\n\n(51,375)10\n(564,32)10\n\n\n\n\n1.6.2 Conversions vers octal\nNous pouvons utiliser la command oct de Python pour convertir des entiers décimaux en octal.\n\nprint(oct(115))\nprint(oct(71))\n\n0o163\n0o107\n\n\n\n\n1.6.3 Conversions vers hexadécimal\n\nExemple 1.13 Convertissez les nombres décimaux suivants en hexadécimal.\n\n(176,47)10\n(69,28)10\n\n\nNous pouvons utiliser la command hex de Python pour convertir des entiers décimaux en hexadécimal.\n\nprint(hex(115))\nprint(hex(71))\n\n0x73\n0x47\n\n\n\n\n1.6.4 Conversions binaire - hexadécimal\nUne des raisons pour lesquelles le format hexadécimal a été inventé est qu’il est particulièrement simple de convertir un nombre binaire en nombre hexadécimal et inversement.\n\n\n\nHexa\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\nBinaire\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n\n\nHexa\n8\n9\nA\nB\nC\nD\nE\nF\n\n\nBinaire\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\n\n\nPour convertir un nombre binaire, on regroupe par paquets de 4 chiffres à partir de la virgule (pour la partie entière et la partie fractionnaire).\n\nExemple 1.14 Convertissez les nombres binaires suivants en hexadécimal.\n\n\\((111001,1101)_2\\)\n\\((1110001,11\\overline{001})_2\\)\n\n\n\nExemple 1.15 Convertissez les nombres hexadécimaux suivants en binaire.\n\n\\((537,14)_{16}\\)\n\\((45B,1\\overline{DE})_{16}\\)"
  },
  {
    "objectID": "representation_nombres_ordinateurs.html#représentation-des-entiers",
    "href": "representation_nombres_ordinateurs.html#représentation-des-entiers",
    "title": "2  Représentation des nombres dans l’ordinateur",
    "section": "2.1 Représentation des entiers",
    "text": "2.1 Représentation des entiers\nEn Python, contrairement à la plupart des langages informatiques, les entiers sont représentés avec une précision infinie. C’est-à-dire que la seule limite correspond à la mémoire interne de la machine que vous utilisez. Cependant, dans la majorité des langages informatiques, la précision de la représentation des entiers est finie, c’est-à-dire qu’un certain nombre de bits est alloué en mémoire pous stocker votre nombre et vous ne pouvez pas le dépasser.\nNous pouvons connaître le nombre de bits utilisés par Python dans la représentation d’un entier en utilisant la fonction getsizeof du module sys.\n\nfrom sys import getsizeof\n\nn1 = 2**32\nn2 = 2**128\nprint(getsizeof(n1), getsizeof(n2))\n\n32 44\n\n\nPour étudier le comportement d’entiers ayant une taille fixe, on peut utiliser le module numpy. Ce module possède plusieurs classes d’entiers à taille fixe.\n\n2.1.1 Entiers non signés\n\nDéfinition 2.1 (Entiers non signés (nombres positifs)) Un nombre entier non signé (positif) est représenté par un nombre de bits préalablement fixé. Au besoin, on complète le nombre par des zéros à gauche fin d’avoir le nombre total de bits choisi.\n\n\n\n\n\n\n\nLes entiers non signés à taille fixe en Python\n\n\n\n\nnumpy.ubyte: entier non signé sur 8 bits\nnumpy.ushort: entier non signé sur 16 bits\nnumpy.uintc: entier non signé sur 32 bits\nnumpy.uint: entier non signé sur 64 bits\n\n\n\n\nExemple 2.1 Transformez les entiers décimaux suivants en entiers non signés sur un octet (huit bits).\n\n143\n15\n30\n\n\n\nimport numpy as np\n\nprint(bin(np.ubyte(143)), bin(np.ubyte(15)), bin(np.ubyte(30)))\n\n0b10001111 0b1111 0b11110\n\n\n\n\n\n\n\n\nSoyez prudents!\n\n\n\nSi on tente d’écrire un nombre entier qui dépasse la capacité du format, nous n’obtenons pas nécessairement un message d’erreur, il faut donc être très prudents. Par exemple, le format numpy.byte peut représenter les entiers de 0 à 255. Si nous tentons de représenter 256, nous obtenons:\n\nimport numpy as np\n\nprint(np.uint8(256))\n\n0\n\n\n\n\nCe genre d’erreur est appelée un dépassement d’entier. Un dépassement d’entier (integer overflow) est, en informatique, une condition qui se produit lorsqu’une opération mathématique produit une valeur numérique supérieure à celle représentable dans l’espace de stockage disponible. Par exemple, l’ajout d’une unité au plus grand nombre pouvant être représenté entraîne un dépassement d’entier.\nLe dépassement d’entier le plus célèbre de ces dernières années est très probablement celui qui causa la destruction de la fusée Ariane 5, lors de son vol inaugural, le 4 juin 1996.\n\nExemple 2.2 Quel est le plus grand entier non signé pouvant être représenté avec:\n\n8 bits?\n32 bits?\n\\(n\\) bits?\n\n\n\n\n2.1.2 Entiers signés\nPour travailler avec des entiers qui peuvent être positifs ou négatifs, il faut inclure le signe du nombre dans sa représentation, et l’on parle alors d’entiers signés.\n\nDéfinition 2.2 (Entiers signés (représentation signe et module)) Un nombre entier signé (généralement représenté dans un octet) est un nombre où le 1er bit (à gauche) est réservé au signe, et les autres bits permettent d’indiquer la valeur absolue du nombre. Pour indiquer qu’un nombre est positif (+), le 1er bit est 0, et pour un nombre négatif (-), le 1er bit est 1.\n\n\n\n\n\n\n\nLes entiers signés à taille fixe en Python\n\n\n\n\nnumpy.byte: entier signé sur 8 bits\nnumpy.short: entier signé sur 16 bits\nnumpy.intc: entier signé sur 32 bits\nnumpy.int_: entier signé sur 64 bits\n\n\n\n\nExemple 2.3 Complétez les tableaux suivants qui indiquent la représentation signe et module sur 4 bits.\n\n\n\n\n\nBase 2\nBase 10\n\n\n\n\n0000\n\n\n\n0001\n\n\n\n0010\n\n\n\n0011\n\n\n\n0100\n\n\n\n0101\n\n\n\n0110\n\n\n\n0111\n\n\n\n\n\n\n\n\n\n\nBase 2\nBase 10\n\n\n\n\n1000\n\n\n\n1001\n\n\n\n1010\n\n\n\n1011\n\n\n\n1100\n\n\n\n1101\n\n\n\n1110\n\n\n\n1111\n\n\n\n\n\n\n\nEn utilisant les nombres entiers signés:\n\nOn peut écrire autant de nombres positifs que de négatifs.\nPour un nombre exprimé avec \\(n\\) bits, les valeurs extrèmes sont \\(\\pm(2^{n-1}-1)\\)\n\n\nExemple 2.4 Quelles sont les valeurs extrèmes pour des entiers signés représentés sur 4 bits?\n\n\n\n\n\n\n\nInconvénients de la représentation signe et module\n\n\n\n\nIl y a deux zéros! Un zéro positif (0000 0000) et un zéro négatif (1000 0000).\nLes opérations arithmétiques ne se font pas de la même manière qu’habituellement. Par exemple, sur 4 bits:\n\nBase 2: 0100 + 1011 = 1111\nBase 10: +4 + -3 = -7! (FAUX!)\n\n\n\n\n\nExemple 2.5 Écrivez la représentation signe et module sur 8 bits de:\n\n15\n\n\n\n\n\n\n\n-15\n\n\n\n\n\n\n\n-10\n\n\n\n\n\n\n\nQuel est l’intervalle de nombres entiers signés pouvant être représentés avec:\n\n8 bits?\n16 bits?"
  },
  {
    "objectID": "representation_nombres_ordinateurs.html#format-dun-nombre-en-virgule-flottante",
    "href": "representation_nombres_ordinateurs.html#format-dun-nombre-en-virgule-flottante",
    "title": "2  Représentation des nombres dans l’ordinateur",
    "section": "2.2 Format d’un nombre en virgule flottante",
    "text": "2.2 Format d’un nombre en virgule flottante\nLa virgule flottante est une méthode d’écriture de nombres fréquemment utilisée dans les ordinateurs, équivalente à la notation scientifique en numération binaire.\nPar exemple: \\[\n+13,254 = \\underbrace{+}_{\\text{signe}} \\underbrace{0,13254}_{\\text{mantisse}} \\times 10^{\\overbrace{{2}}^{\\text{exposant}}}\n\\]\n\nFormat général\nUn nombre flottant est formé de trois éléments : la mantisse, l’exposant et le signe. Le bit de poids fort est le bit de signe : si ce bit est à 1, le nombre est négatif, et s’il est à 0, le nombre est positif. Les \\(e\\) bits suivants représentent l’exposant biaisé (sauf valeur spéciale), et les \\(m\\) bits suivants (\\(m\\) bits de poids faible) représentent la mantisse.\n\n\n\n\n\nSigne\nExposant biaisé\nMantisse\n\n\n\n\n(1 bit)\n(e bits)\n(m bits)\n\n\n\n\n\n\n\n\n\nFormat général de représentation des flottants\n\n\n\n\nNous reviendrons sur l’exposant biaisé à la section Section 2.3.\n\n\n2.2.1 Opérations sur les nombres en virgule flottante\nPour simplifier la présentation et la compréhension, nous utiliserons la base décimale avec 7 chiffres de précision, tout comme le format binary32 (format à simple précision), que nous verrons plus tard. Les principes fondamentaux sont les mêmes peu importe la base et le nombre de chiffres de précision. Nous utiliserons \\(f\\) pour désigner la mantisse (en anglais on parle de float) et \\(e\\) pour désigner l’exposant.\n\n2.2.1.1 Additions et soustractions\nPour additionner (ou soustraire) des nombres en virgule flottante, nous devons les représenter avec le même exposant. La convention est de modifier l’exposant le plus petit pour le rendre égal à l’exposant le plus grand.\n\\[\n\\begin{array}{rrll}\n& e=5; & s=1,234567 & (123456,7) \\\\\n+ & e=2; & s=1,017654 & (101,7654) \\\\ \\\\\n\\hline\n\\\\\n& e=5; & s=1,234567 &  \\\\\n+ & e=5; & s=0,01017654 & (\\text{après déplacement de la virgule}) \\\\ \\\\\n\\hline\n\\\\\n& e=5; & s=1,235584654 & (\\text{somme réelle}: 123558,4654)\n\\end{array}\n\\]\nLe résultat précédent correspond à la somme réelle des deux nombres. Le résultat sera ensuite arrondi à 7 chiffres et normalisé si nécessaire. Le résultat final est:\n\\[\n\\begin{array}{rrll}\n& e=5; & s=1,235585 & (\\text{somme finale}: 123558,5)\n\\end{array}\n\\]\nLes trois derniers chiffres du second nombre (654) sont essentiellement perdus. C’est ce que nous appelons l’erreur d’arrondi. Dans des cas extrèmes, la somme de deux nombres différents de zéro peut être égale à un de ces nombre.\n\nExemple 2.6 Additionnez les deux nombres 123456,7 et 0,009876543, en utilisant 7 chiffres pour la mantisse.\n\n\n\n\n\n\n\nAttention\n\n\n\nDans l’exemple précédent, il semblerait qu’un grand nombre de chiffres supplémentaires soit nécessaire pour s’assurer d’obtenir le bon résultat. En pratique, pour l’addition ou la soustraction en binaire, en utilisant une bonne implémentation, seulement un guard bit, un rounding bit et un sticky bit sont nécessaires pour obtenir un bon résultat.\n\n\nUn autre problème peut se produire lorsque des approximations de deux nombres presque égaux sont soustraites.\n\nExemple 2.7 Effectuez la soustraction de 123457,1467 et 123456,659, en utilisant 7 chiffres pour la mantisse.\n\n\nExemple 2.8 Calculez l’erreur relative faite à l’Exemple 2.7.\n\n\n\n\n\n\n\nAttention\n\n\n\nL’annulation catastrophique de l’Exemple 2.7 illustre le danger de supposer que tous les chiffres d’un résultat sont pertinents.\n\n\n\nExemple 2.9 Soit deux nombres \\(x\\) et \\(y\\). La manière naïve de calculer la fonction \\(x^2-y^2\\) en virgule flottante est sujette à l’annulation catastrophique, lorsque \\(x\\) et \\(y\\) sont proches. En effet, la soustraction peut faire apparaître les erreurs d’arrondi dans l’élévation au carré. La fonction factorisée \\((x+y)(x-y)\\) évite l’annulation catastrophique car elle évite d’introduire des erreurs d’arrondis avant la soustraction.\n\nx = 1+2**(-29)\ny = 1+2**(-30)\n\nds1 = x**2-y**2\nds2 = (x+y)*(x-y)\nerr = abs(ds1-ds2)/ds2\n\nprint(ds1, ds2, err)\n\n1.862645149230957e-09 1.8626451518330422e-09 1.3969838599716539e-09\n\n\n\n\n\n2.2.1.2 Multiplications et divisions\nContrairement à l’addition et la soustraction, il n’y a pas de problème d’annulation catastrophique pour la multiplication ou la division.\nPour multiplier, les mantisses sont multipliées et les exposants sont additionnés. Le résultat est ensuite arrondi et normalisé. Pour diviser, les mantisses sont divisées et les exposants sont soustraits. Le résultat est ensuite arrondi et normalisé.\n\nExemple 2.10 Effectuez la multiplication de 4734,612 et 541724,2, en utilisant 7 chiffres pour la mantisse."
  },
  {
    "objectID": "representation_nombres_ordinateurs.html#sec-ieee754",
    "href": "representation_nombres_ordinateurs.html#sec-ieee754",
    "title": "2  Représentation des nombres dans l’ordinateur",
    "section": "2.3 La norme IEEE754",
    "text": "2.3 La norme IEEE754\nEn informatique, l’IEEE 754 est une norme sur l’arithmétique à virgule flottante mise au point par le Institute of Electrical and Electronics Engineers. Elle est la norme la plus employée actuellement pour le calcul des nombres à virgule flottante avec les CPU et les FPU. La norme définit les formats de représentation des nombres à virgule flottante (signe, mantisse, exposant, nombres dénormalisés) et valeurs spéciales (infinis et NaN), en même temps qu’un ensemble d’opérations sur les nombres flottants. Il décrit aussi cinq modes d’arrondi et cinq exceptions (comprenant les conditions dans lesquelles une exception se produit, et ce qui se passe dans ce cas).\n\n\n\nFormat général d’un nombre en virgule flottante.\n\n\n\nBiais de l’exposant\nL’exposant peut être positif ou négatif. Cependant, la représentation habituelle des nombres signés (complément à 2) rendrait la comparaison entre les nombres flottants un peu plus difficile. Pour régler ce problème, l’exposant est biaisé, afin de le stocker sous forme d’un nombre non signé. Le terme biaisé signifie que l’exposant est stocké sous forme d’entier positif, mais pour trouver l’exposant réel, il faut soustraire une valeur (le biais) à celle stockée.\nCe biais est de \\(2^{e-1}-1\\) (\\(e\\) représente le nombre de bits de l’exposant) ; il s’agit donc d’une valeur constante une fois que le nombre de bits \\(e\\) est fixé.\nPar exemple, dans le cas où l’exposant est composé de 8 bits, nous avons \\(e=8\\) et le biais est de \\(2^{8-1}-1=127\\).\nL’interprétation d’un nombre (autre qu’infini) est donc : valeur = signe x 2(exposant−biais) x mantisse avec:\n\nsigne = \\(\\pm\\) 1\nbiais = \\(2^{e-1}-1\\)\n\n\n\nExceptions\nLe bit de poids fort de la mantisse est déterminé par la valeur de l’exposant biaisé. Si l’exposant biaisé est différent de 0 et de \\(2^e-1\\), le bit de poids fort de la mantisse est 1, et le nombre est dit normalisé. Si l’exposant biaisé est nul, le bit de poids fort de la mantisse est nul, et le nombre est dénormalisé.\nIl y a trois cas particuliers:\n\nsi l’exposant biaisé et la mantisse sont tous deux nuls, le nombre est \\(\\pm\\) 0 (selon le bit de signe)\nsi l’exposant biaisé est égal à \\(2^e-1\\), et si la mantisse est nulle, le nombre est \\(\\pm\\) infini (selon le bit de signe)\nsi l’exposant biaisé est égal à \\(2^e-1\\), mais que la mantisse n’est pas nulle, le nombre est NaN (not a number : pas un nombre).\n\nUn nombre flottant normalisé a une valeur \\(v\\) donnée par la formule suivante: \\[\nv = s \\times 2^e \\times (1+f)\n\\]\n\n\\(s=\\pm 1\\) représente le signe (selon le bit de signe);\n\\(e\\) est l’exposant avant son biais de \\(2^{e-1}-1\\);\n\\(f\\) représente un nombre en binaire compris entre 0 et 1.\n\nLes nombres dénormalisés suivent le même principe, sauf qu’une seule valeur de \\(e\\) est possible, \\(e=2-2^{e-1}\\). Nous avons donc \\[\nv = s \\times 2^e \\times (0+f)\n\\]\n\n\n\n\n\n\nNote\n\n\n\n\nIl y a deux zéros: +0 et -0 (zéro positif et zéro négatif), selon la valeur du bit de signe;\nIl y a deux infinis: \\(+\\infty\\) et \\(-\\infty\\), selon la valeur du bit de signe;\nLes zéros et les nombres dénormalisés ont un exposant biaisé de 0; tous les bits du champ exposant sont donc à 0;\nLes NaNs et les infinis ont un exposant biaisé de \\(2^e-1\\); tous les bits du champ exposant sont donc à 1;\nLes NaNs peuvent avoir un signe et une partie significative mais ceux-ci n’ont aucun sens en tant que valeur réelle (sauf pour la signalisation, qui peut activer une exception, et la correction d’erreurs) ;\n\n\n\nLa mantisse est représentée par: \\[\n\\begin{aligned}\nf &= \\sum_{i=1}^{m} b_i 2^{-i}, \\qquad b_i \\in \\{0, 1 \\} \\\\\n&= b_1 2^{-1}+b_2 2^{-2}+\\ldots + b_m 2^{-m}\n\\end{aligned}\n\\tag{2.1}\\] pour un entier fixé \\(m\\), la taille de la mantisse. L’équation (Équation 2.1) représente des nombres dans l’intervalle \\([1,2[\\). De manière équivalente, nous pouvons écrire \\[\n\\begin{aligned}\nf &= 2^{-m} \\sum_{i=1}^{m} b_i 2^{m-i} = 2^{-m} z, \\qquad b_i \\in \\{0, 1 \\}\n\\end{aligned}\n\\tag{2.2}\\] pour un entier \\(z\\) dans l’ensemble \\(\\{ 0, 1, \\ldots, 2^m-1 \\}\\).\n\nExemple 2.11 Écrivez toutes les mantisses possibles si le nombre de bits de la mantisse est de 1, c’est-à-dire \\(m=1\\).\n\n\nExemple 2.12 Écrivez toutes les mantisses possibles si le nombre de bits de la mantisse est de 2, c’est-à-dire \\(m=2\\).\n\n\n\n\n\n\n\nNote\n\n\n\nL’expression \\(f = \\sum_{i=1}^{m} b_i 2^{-i}\\) peut être calculée facilement lorsque tous les \\(b_i=1\\). Nous obtenons: \\[\nf = \\sum_{i=1}^{m} 1 \\cdot 2^{-i} = 2-2^{-m}\n\\]\n\n\n\nDéfinition 2.3 (L’epsilon d’une machine) L’epsilon d’une machine est défini comme le plus petit nombre qui, ajouté à un, donne un résultat différent de un.\nEn utilisant l’équation (Équation 2.2), nous remarquons que le plus petit nombre (autre que 0) possible est \\(2^{-m}\\).\nPour déterminer l’epsilon de la machine en Python, on utilise la commande sys.float_info.epsilon du module sys.\n\nimport sys\nsys.float_info.epsilon\n\n2.220446049250313e-16\n\n\n\nNous pouvons aussi utiliser un petit programme pour déterminer l’epsilon de la machine.\n\neps = 1.0\nwhile eps + 1 &gt; 1:\n    eps /= 2\neps *= 2\nprint(\"L'epsilon machine est:\", eps)\n\nL'epsilon machine est: 2.220446049250313e-16\n\n\nEn clair, si nous additionnons un nombre plus petit que l’epsilon machine, le résultat reste inchangé.\n\nimport sys\neps = sys.float_info.epsilon\nprint(1+eps, 1+eps/2)\n\n1.0000000000000002 1.0\n\n\n\n\n2.3.1 Le format à virgule flottante à précision simple\nLe standard IEEE 754 spécifie un format à précision simple comme:\n\nun signe : 1 bit\nexposant biaisé : 8 bits\nmantisse : 23 bits + 1 bit implicite\n\nL’exposant est un entier non signé de 8 bits de 0 à 255 sous la forme biaisée, c’est-à-dire que pour obtenir l’exposant réel, nous devons lui soustraire 127. Les exposants peuvent prendre les valeurs entières de -126 à +127 car les exposants -127 (seulement des zéros) et +128 (seulement des uns) sont réservés pour des nombres spéciaux.\n\n\n\n\n\nLa valeur est donc donnée par:\n\\[\n(-1)^{b_{31}}\\times 2^{(b_{30}b_{29}\\ldots b_{23})_2-127}\\times (1,b_{22}b_{21}\\ldots b_0)_2\n\\] ce qui donne \\[\n\\text{valeur}=(-1)^{\\text{signe}}\\times 2^{(E-127)}\\times \\left( 1+ \\sum_{i=1}^{23} b_{23-i} 2^{-i}\\right)\n\\]\nDans l’exemple précédent, nous avons:\n\nsigne = \\(b_{31}\\) = 0;\n\\((-1)^{\\text{signe}}=(-1)^0=+1\\in \\{-1,+1\\}\\);\n\\(E=(b_{30}b_{29}\\ldots b_{23})_2=\\sum_{i=0}^7 b_{23+i}2^{+i}=124\\in \\{1,\\ldots, (2^8-1)-1\\}=\\{1,\\ldots, 254\\}\\);\n\\(2^{(E-127)}=2^{124-127}=2^{-3}\\in \\{2^{-126},\\ldots, 2^{127}\\}\\);\n\\(1,b_{22}b_{21}\\ldots b_0=1+\\sum_{i=1}^{23} b_{23-i}2^{-i}=1+1\\cdot 2^{-2}=1,25\\in \\{1,1+2^{-23},\\ldots, 2-2^{-23}\\} \\subset [1;2-2^{-23}] \\subset [1;2[\\)\n\n\nL’encodage de l’exposant\nL’exposant du format à virgule flottante à précision simple est encodé de manière biaisée, avec un biais de 127 (\\(2^{e-1}-1=2^{8-1}-1\\)).\n\nEmin=0116-7F16=-126\nEmax=FE16-7F16=127\nBiais de l’exposant = 7F16=127\n\nPour obtenir l’exposant véritable, on doit soustraire 127 à l’exposant stocké.\nLes exposants 0016 et FF16 ont une interprétation spéciale.\n\n\n\n\n\n\n\n\n\nExposant\nFraction = 0\nFraction \\(\\neq\\) 0\nÉquation\n\n\n\n\n0016\n\\(\\pm\\) zéro\nnombre dénormalisé\n\\((-1)^{\\text{signe}}\\times 2^{-126}\\times 0,\\text{fraction}\\)\n\n\n0116,…,FE16\nvaleur normale\nvaleur normale\n\\((-1)^{\\text{signe}}\\times 2^{\\text{exposant}-127}\\times 1,\\text{fraction}\\)\n\n\nFF16\n\\(\\pm\\) infini\nNaN\n\n\n\n\n\n\nCas particuliers dans le format virgule flottante à précision simple\nPour les exemples suivants, trouvez la représentation sous forme binaire et hexadécimale.\n\nExemple 2.13 Trouvez le plus petit nombre dénormalisé positif.\n\n\nExemple 2.14 Trouvez le plus grand nombre dénormalisé positif.\n\n\nExemple 2.15 Trouvez le plus petit nombre normalisé positif.\n\n\nExemple 2.16 Trouvez le plus grand nombre normalisé positif.\n\n\nExemple 2.17 Trouvez le plus grand nombre plus petit que un.\n\n\n\n\n2.3.2 Le format à virgule flottante à précision double\nFloat Toy\nPrinceton Float\nCheatsheets for ieee 754 representation\nIEEE754 Wiki Wand"
  },
  {
    "objectID": "logique.html#logique-propositionnelle",
    "href": "logique.html#logique-propositionnelle",
    "title": "3  Logique",
    "section": "3.1 Logique propositionnelle",
    "text": "3.1 Logique propositionnelle\n\nDéfinition 3.1 (Proposition) Un énoncé qui est soit vrai, soit faux est appelé une proposition. La valeur de vérité d’une proposition est donc VRAI ou FAUX.\nEn Python, les valeurs de vérités sont données par True (VRAI) et False (FAUX).\n\nUn énoncé qui n’est pas une proposition (comme un paradoxe, une phrase impérative ou interrogative) sera qualifié d’innaceptable.\n\nExemple 3.1 Les énoncés suivants sont des propositions:\n\nLes numéros de téléphones au Canada ont dix chiffres.\nLa lune est faite de fromage.\n42 est la réponse à la question portant sur la vie, l’univers et tout ce qui existe.\nChaque nombre pair plus grand que 2 peut être exprimé comme la somme de deux nombres premiers.\n\\(3+7=12\\)\n\nLes énoncés suivants ne sont pas des propositions:\n\nVoulez-vous du gâteau?\nLa somme de deux carrés.\n\\(1+3+5+7+\\ldots +2n+1\\).\nVa dans ta chambre!\n\\(3+x=12\\)\n\n\nNous utilisons une table de vérité pour montrer les valeurs de vérité de propositions composées.\n\n3.1.1 La négation\n\nDéfinition 3.2 (La négation) Soit \\(p\\) une proposition. L’énoncé:\n\nIl n’est pas vrai que \\(p\\).\n\nest une autre proposition appelée négation de \\(p\\), qui est représentée par \\(\\lnot p\\). La proposition \\(\\lnot p\\) se lit non \\(p\\). La table de vérité de la négation est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(\\lnot p\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, l’opérateur not permet de faire la négation d’une valeur de vérité.\n\ndef negation(p):\n    return not p\n\nprint(\"p    non_p\")\nfor p in [True, False]:\n    non_p = negation(p)\n    print(p, non_p)\n\np    non_p\nTrue False\nFalse True\n\n\n\n\n\n3.1.2 La conjonction\n\nJe suis une roche ET je suis une île.\n\n\nDéfinition 3.3 (La conjonction) Soit \\(p\\) et \\(q\\) deux propositions. La proposition \\(p\\) et \\(q\\), notée \\(p\\wedge q\\), est vraie si à la fois \\(p\\) et \\(q\\) sont vraies. Elle est fausse dans tous les autres cas. Cette proposition est appelée la conjonction de \\(p\\) et de \\(q\\). La table de vérité de la conjonction est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\wedge q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, l’opérateur and permet de faire la conjonction de deux valeurs de vérité.\n\ndef conjonction(p, q):\n    return p and q\n\nprint(\"p    q    p_et_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_et_q = conjonction(p, q)\n        print(p, q, p_et_q)\n\np    q    p_et_q\nTrue True True\nTrue False False\nFalse True False\nFalse False False\n\n\n\n\n\n3.1.3 La disjonction\n\nElle a étudié très fort OU elle est extrêmement brillante.\n\n\nDéfinition 3.4 (La disjonction) Soit \\(p\\) et \\(q\\) deux propositions. La proposition \\(p\\) ou \\(q\\), notée \\(p\\vee q\\), est fausse si \\(p\\) et \\(q\\) sont fausses. Elle est vraie dans tous les autres cas. Cette proposition est appelée la disjonction de \\(p\\) et de \\(q\\). La table de vérité de la disjonction est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\vee q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, l’opérateur or permet de faire la disjonction de deux valeurs de vérité.\n\ndef disjonction(p, q):\n    return p or q\n\nprint(\"p    q    p_ou_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_ou_q = disjonction(p, q)\n        print(p, q, p_ou_q)\n\np    q    p_ou_q\nTrue True True\nTrue False True\nFalse True True\nFalse False False\n\n\n\n\n\n3.1.4 La disjonction exclusive\n\nPrenez SOIT deux Advil OU deux Tylenols.\n\n\nDéfinition 3.5 (La disjonction exclusive) Soit \\(p\\) et \\(q\\) deux propositions. La proposition \\(p\\) ou exclusif \\(q\\), notée \\(p\\oplus q\\), est vraie si \\(p\\) et \\(q\\) ont des valeurs de vérité différentes. Elle est fausse dans tous les autres cas. Cette proposition est appelée la disjonction exclusive de \\(p\\) et de \\(q\\). La table de vérité de la disjonction exclusive est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\oplus q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, il n’existe pas d’opérateur logique pour effectuer la disjonction exclusive. On peut par contre utiliser l’opérateur bit à bit ^ pour faire cette disjonction exclusive.\n\n\nExemple 3.2 Utilisez les opérateurs logiques vus précédemment pour construire la table de vérité de la disjonction exclusive dans Python.\n\ndef disjonction_exclusive(p, q):\n    return #REMPLACEZ MOI#\n\nprint(\"p    q    p_ou_exclusif_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_ou_exclusif_q = disjonction_exclusive(p, q)\n        print(p, q, p_ou_exclusif_q)\n\n\n\np    q    p_ou_exclusif_q\nTrue True False\nTrue False True\nFalse True True\nFalse False False\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa disjonction exclusive signifie l’un ou l’autre, mais pas les deux.\n\n\n\n\n3.1.5 L’implication\n\nSI vous avez 100 à l’examen final, ALORS vous obtiendrez A dans ce cours.\n\n\nDéfinition 3.6 (L’implication) Soit \\(p\\) et \\(q\\) deux propositions. L’implication \\(p\\rightarrow q\\) est une proposition qui est fausse quand \\(p\\) est vraie et que \\(q\\) est fausse, et qui est vraie dans tous les autres cas. Dans une implication, \\(p\\) est appelée l’hypothèse (ou l’antécédent ou la prémisse) et \\(q\\), la conclusion (ou la conséquence). La table de vérité de l’implication’ est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\rightarrow q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, il n’existe pas d’opérateur logique pour effectuer l’implication.\n\n\nExemple 3.3 Utilisez les opérateurs logiques vus précédemment pour construire la table de vérité de l’implication dans Python.\n\ndef implication(p, q):\n    return #REMPLACEZ MOI#\n\nprint(\"p    q    p_implique_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_implique_q = implication(p, q)\n        print(p, q, p_implique_q)\n\n\n\np    q    p_implique_q\nTrue True True\nTrue False False\nFalse True True\nFalse False True\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nUne implication peut être considérée comme un contrat qui échoue seulement si les conditions du contrat sont respectées mais les résultats ne sont pas remplis.\n\n\nComme les implications apparaissent constamment en mathématiques, il existe une vaste terminologie pour désigner \\(p\\rightarrow q\\). Voici les modes les plus courants:\n\nsi \\(p\\) alors \\(q\\);\n\\(p\\) implique \\(q\\);\n\\(p\\) seulement si \\(q\\);\n\\(p\\) est suffisant pour \\(q\\);\n\\(q\\) si \\(p\\);\n\\(q\\) chaque fois que \\(p\\);\n\\(q\\) est nécessaire à \\(p\\).\n\n\n\n3.1.6 La biconditionnelle\n\nIl pleut dehors SI ET SEULEMENT SI c’est un jour nuageux.\n\n\nDéfinition 3.7 (La biconditionnelle) Soit \\(p\\) et \\(q\\) deux propositions. La biconditionnelle \\(p\\leftrightarrow q\\) est une proposition qui est vraie quand \\(p\\) et \\(q\\) ont les mêmes valeurs de vérité et qui est fausse dans les autres cas. La table de vérité de la biconditionnelle est donnée ci-dessous.\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\leftrightarrow q\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\nEn Python, il n’existe pas d’opérateur logique pour effectuer la biconditionnelle.\n\n\nExemple 3.4 Utilisez les opérateurs logiques vus précédemment pour construire la table de vérité de la biconditionnelle dans Python.\n\ndef biconditionnelle(p, q):\n    return #REMPLACEZ MOI#\n\nprint(\"p    q    p_biconditionnelle_q\")\nfor p in [True, False]:\n    for q in [True, False]:\n        p_biconditionnelle_q = biconditionnelle(p, q)\n        print(p, q, p_biconditionnelle_q)\n\n\n\np    q    p_biconditionnelle_q\nTrue True True\nTrue False False\nFalse True False\nFalse False True\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa biconditionnelle est vraie si les propositions ont la même valeur de vérité et fausse autrement.\n\n\nComme les biconditionnelles apparaissent constamment en mathématiques, il existe une vaste terminologie pour désigner \\(p\\leftrightarrow q\\). Voici les modes les plus courants:\n\n\\(p\\) si et seulement si \\(q\\);\n\\(p\\) est nécessaire et suffisante pour \\(q\\);\nsi \\(p\\) alors \\(q\\) et réciproquement.\n\n\nDéfinition 3.8 (Réciproque, contraposée et inverse)  \n\nLa réciproque de la proposition \\(p\\rightarrow q\\) est la proposition \\(q \\rightarrow p\\).\nLa contraposée de la proposition \\(p\\rightarrow q\\) est la proposition \\(\\lnot q \\rightarrow \\lnot p\\).\nL’inverse de la proposition \\(p\\rightarrow q\\) est la proposition \\(\\lnot p \\rightarrow \\lnot q\\)."
  },
  {
    "objectID": "logique.html#équivalences-propositionnelles",
    "href": "logique.html#équivalences-propositionnelles",
    "title": "3  Logique",
    "section": "3.2 Équivalences propositionnelles",
    "text": "3.2 Équivalences propositionnelles\nUne proposition composée est une proposition formée de plusieurs connecteurs logiques.\n\nDéfinition 3.9 (Tautologie, contradiction et contingence) Une proposition composée qui est toujours vraie, quelle que soit la valeur de vérité des fonctions qui la compose est appelée une tautologie. Une proposition composée qui est toujours fausse est appelée une contradiction. Finalement, une proposition qui n’est ni une tautologie ni une contradiction est appelée une contingence.\n\n\nExemple 3.5 Remplissez la table de vérité suivante et dites si les propositions composées sont des tautologies, des contradictions ou des contingences.\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\vee \\lnot p\\)\n\\(p \\wedge \\lnot p\\)\n\n\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\n\nExemple 3.6 Le code ci-dessous révèle la table de vérité de la proposition composée \\((p \\wedge q) \\vee \\lnot q\\).\n\ndef conjonction(p, q):\n    return p and q\n\ndef disjonction(p, q):\n    return p or q\n\nprint(\"p    q    a\")\nfor p in [True, False]:\n    for q in [True, False]:\n        a = disjonction(conjonction(p, q), not q)\n        print(p, q, a)\n\np    q    a\nTrue True True\nTrue False True\nFalse True False\nFalse False True\n\n\nDe quelle manière pouvez-vous modifier le code précédent pour obtenir la table de vérité de la proposition composée \\((p \\vee \\lnot q) \\wedge \\lnot p\\)?\n\nLorsque vous créez votre table de vérité, il est crucial que vous soyiez systématique pour vous assurer d’avoir toutes les valeurs de vérité possibles pour chacune des propositions simples. Chaque proposition a deux valeurs de vérité possibles, le nombre de lignes de la table devrait être égal à \\(2^n\\), où \\(n\\) est le nombre de propositions. Vous devriez également considérer de briser vos propositions complexes en plus petites propositions.\n\nExemple 3.7 L’extrait de code suivant fait intervenir les variables booléennes \\(p\\), \\(q\\) et \\(r\\). Chacune de ces variables peut prendre les valeurs vrai ou faux. Pour chaque bloc indiqué, donnez toutes les valeurs possibles pour \\(p\\), \\(q\\) et \\(r\\) au moment où le bloc est atteint.\n\nif (p and q):\n    if r:\n        #BLOC 1#\n    else:\n        #BLOC 2#\nelse:\n    #BLOC 3#\n\n\n\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(r\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\nV\n\n\n\n\n\nV\nV\nF\n\n\n\n\n\nV\nF\nV\n\n\n\n\n\nV\nF\nF\n\n\n\n\n\nF\nV\nV\n\n\n\n\n\nF\nV\nF\n\n\n\n\n\nF\nF\nV\n\n\n\n\n\nF\nF\nF\n\n\n\n\n\n\n\n\nDéfinition 3.10 (Équivalences de propositions) Les propositions \\(p\\) et \\(q\\) sont dites logiquement équivalentes si la proposition \\(p \\leftrightarrow q\\) est une tautologie. Ainsi, deux propositions sont logiquement équivalentes si elles ont la même table de vérité, c’est-à-dire la même valeur de vérité dans tous les cas possibles.\nLa notation \\(p\\equiv q\\) signifie que \\(p\\) et \\(q\\) sont équivalentes.\n\n\nExemple 3.8 Vérifiez l’équivalence suivante à l’aide d’une table de vérité. \\[\np \\rightarrow q \\equiv \\lnot p \\vee q\n\\]\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\n\n\n\n\n\nV\nF\n\n\n\n\n\nF\nV\n\n\n\n\n\nF\nF\n\n\n\n\n\n\n\n\nExemple 3.9 Vérifiez l’équivalence suivante à l’aide d’une table de vérité. \\[\n\\lnot (p \\vee q) \\equiv \\lnot p \\wedge \\lnot q\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\n\n\n\n\n\n\n\nV\nF\n\n\n\n\n\n\n\nF\nV\n\n\n\n\n\n\n\nF\nF\n\n\n\n\n\n\n\n\n\nPour gagner du temps, on note les équivalences fréquemment utilisées dans une table et on leur donne un nom ou un numéro afin d’y faire référence.\n\n\nTable 3.1: Équivalences logiques\n\n\n\n\n\n\n\nNom\nÉquivalence 1\nÉquivalence 2\n\n\n\n\nIdentité\n\\(p \\wedge \\mathbf{V} \\equiv p\\)\n\\(p \\vee \\mathbf{F} \\equiv p\\)\n\n\nDomination\n\\(p \\vee \\mathbf{V} \\equiv \\mathbf{V}\\)\n\\(p \\wedge \\mathbf{F} \\equiv \\mathbf{F}\\)\n\n\nIdempotence\n\\(p \\vee p \\equiv p\\)\n\\(p\\wedge p \\equiv p\\)\n\n\nDouble négation\n\\(\\lnot (\\lnot p) \\equiv p\\)\n\n\n\nCommutativité\n\\(p\\wedge q \\equiv q \\wedge p\\)\n\\(p \\vee q \\equiv q \\vee p\\)\n\n\nAssociativité\n\\((p \\vee q) \\vee r \\equiv p \\vee (q \\vee r)\\)\n\\((p \\wedge q) \\wedge r \\equiv p \\wedge (q \\wedge r)\\)\n\n\nDistributivité\n\\(p \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r)\\)\n\\(p\\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)\\)\n\n\nLois de De Morgan\n\\(\\lnot (p \\wedge q) \\equiv \\lnot p \\vee \\lnot q\\)\n\\(\\lnot (p \\vee q) \\equiv \\lnot p \\wedge \\lnot q\\)\n\n\nAbsorption\n\\(p \\vee (p \\wedge q) \\equiv p\\)\n\\(p \\wedge (p \\vee q) \\equiv p\\)\n\n\nNégation\n\\(p \\vee \\lnot p \\equiv \\mathbf{V}\\)\n\\(p \\wedge \\lnot p \\equiv \\mathbf{F}\\)\n\n\n\n\n\n\nTable 3.2: Équivalences logiques (implications)\n\n\n\n\n\n\nNuméro\nImplication\n\n\n\n\n1\n\\(p \\rightarrow q \\equiv \\lnot p \\vee q\\)\n\n\n2\n\\(p \\rightarrow q \\equiv \\lnot q \\rightarrow \\lnot p\\)\n\n\n3\n\\(p \\vee q \\equiv \\lnot p \\rightarrow q\\)\n\n\n4\n\\(p \\wedge q \\equiv \\lnot(p \\rightarrow \\lnot q)\\)\n\n\n5\n\\(\\lnot(p \\rightarrow q) \\equiv p \\wedge \\lnot q\\)\n\n\n6\n\\((p \\rightarrow q)\\wedge (p\\rightarrow r) \\equiv p \\rightarrow (q \\wedge r)\\)\n\n\n7\n\\((p \\rightarrow r) \\wedge (q \\rightarrow r) \\equiv (p \\vee q) \\rightarrow r\\)\n\n\n8\n\\((p\\rightarrow q) \\vee (p \\rightarrow r) \\equiv p \\rightarrow (q \\vee r)\\)\n\n\n9\n\\((p \\rightarrow r) \\vee (q \\rightarrow r) \\equiv (p \\wedge q) \\rightarrow r\\)\n\n\n\n\n\n\nTable 3.3: Équivalences logiques (biconditionnelles)\n\n\n\n\n\n\nNuméro\nBiconditionnelle\n\n\n\n\n1\n\\(p \\leftrightarrow q \\equiv (p\\rightarrow q) \\wedge (q \\rightarrow q)\\)\n\n\n2\n\\(p \\leftrightarrow q \\equiv \\lnot p \\leftrightarrow \\lnot q\\)\n\n\n3\n\\(p \\leftrightarrow q \\equiv (p \\wedge q) \\vee (\\lnot p \\wedge \\lnot q)\\)\n\n\n4\n\\(p \\leftrightarrow q \\equiv \\lnot(p \\wedge \\lnot q) \\wedge \\lnot(\\lnot p \\wedge q )\\)\n\n\n5\n\\(\\lnot(p \\leftrightarrow q) \\equiv p \\leftrightarrow \\lnot q\\)\n\n\n\n\n\nExemple 3.10 Vérifiez que la proposition \\[\n\\lnot (p \\rightarrow q) \\rightarrow \\lnot q\n\\] est une tautologie\n\nà l’aide d’une table de vérité;\n\n\n\n\n\n\n\n\n\n\n\n\n\\(p\\)\n\\(q\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\\(\\phantom{V}\\)\n\n\n\n\nV\nV\n\n\n\n\n\n\n\nV\nF\n\n\n\n\n\n\n\nF\nV\n\n\n\n\n\n\n\nF\nF\n\n\n\n\n\n\n\n\nsans l’aide d’une table de vérité, en utilisant les tableaux d’équivalences.\n\n\n\n\n\n\n\n\nPropositions équivalentes ou non?\n\n\n\nPour démontrer que les propositions ne sont pas équivalentes, il suffit de fournir des valeurs de \\(p\\), \\(q\\) et \\(r\\) pour lesquelles elles diffèrent. Pour démontrer que les propositions sont équivalentes, on peut procéder de l’une des trois façons suivantes.\n\nFournir leur table de vérité.\nUtiliser la Table 3.1, la Table 3.2 ou la Table 3.3.\nFormuler une explication en mots qui montre que les deux propositions sont vraies, ou encore que les deux sont fausses, exactement pour les mêmes combinaisons de valeur de vérité des variables propositionnelles."
  },
  {
    "objectID": "logique.html#prédicats-et-quantificateurs",
    "href": "logique.html#prédicats-et-quantificateurs",
    "title": "3  Logique",
    "section": "3.3 Prédicats et quantificateurs",
    "text": "3.3 Prédicats et quantificateurs\nUn énoncé contenant une ou plusieurs variables tel que \\[\nx&lt;10 \\quad \\text{ou} \\quad x+2=7-y\n\\] n’est pas une proposition pusique, tant que la valeur de \\(x\\) ou \\(y\\) n’est pas connue, on ne peut dire s’il est vrai ou faux.\n\nDéfinition 3.11 (Terminologie) Dans l’énoncé “\\(x&lt;10\\)”, \\(x\\) est le sujet, et “est inférieur à 10” est le prédicat. Notons \\(P(x)\\) l’énoncé \\(x&lt;10\\). On dit que \\(P\\) est une fonction propositionnelle.\n\nUne fonction propositionnelle \\(P(x)\\) prend la valeur vrai ou faux quand \\(x\\) est précisé. Par exemple:\n\n\\(P(8)\\) est une proposition vraie. On écrira parfois \\(P(8)\\) est vrai (au masculin, en sous-entendant l’énoncé est vrai, ou même \\(P(8)\\equiv \\mathbf{V}\\)).\n\\(P(13)\\) est une proposition fausse.\n\\(P(\\text{Marc-André})\\) n’est pas une proposition, car Marc-André n’est pas une valeur possible pour la variable \\(x\\).\n\nL’ensemble des valeurs possibles pour la variable \\(x\\) est appelé univers du discours, ou domaine de la fonction \\(P\\).\n\nDéfinition 3.12 (Quantificateurs) \\[\n\\forall:\\ \\text{quantificateur universel} \\qquad \\exists:\\ \\text{quantificateur existentiel}\n\\]\n\n\\(\\forall\\ x\\ P(x)\\):\n\nsignifie “Pour toutes les valeurs de \\(x\\) dans l’univers du discours, \\(P(x)\\)”. Ou encore “Quel que soit \\(x\\) (dans l’univers du discours), \\(P(x)\\)”.\n\n\\(\\exists\\ x\\ P(x)\\):\n\nsignifie “Il existe un élément de \\(x\\) dans l’univers du discours tel que \\(P(x)\\)”. Ou encore “Il y a au moins un \\(x\\) (dans l’univers du discours) tel que \\(P(x)\\)”. Ou encore “Pour un certain \\(x\\) (dans l’univers du discours), \\(P(x)\\)”.\n\n\nNotation. Certains auteurs mettent une virgule avant la fonction propositionnelle, surtout quand celle-ci est composée. Par exemple: \\(\\forall\\ x,\\ (P_1(x)\\rightarrow P_2(x) \\vee P_3(x))\\). Par ailleurs, si l’ensemble \\(U\\) n’a pas déjà été identifié, on peut préciser que la variable \\(x\\) prendra des valeurs dans l’ensemble \\(U\\) ainsi: \\(\\exists\\ x\\in U,\\ P(x)\\).\n\nLorsque l’univers du discours est un ensemble fini \\(\\{x_1,x_2,\\ldots, x_n\\}\\), on a les équivalences logiques suivantes:\n\\[\\begin{align*}\n\\forall\\ x\\ P(x) &\\equiv P(x_1)\\wedge P(x_2) \\wedge \\cdots \\wedge P(x_n) \\\\\n\\exists\\ x\\ P(x) &\\equiv P(x_1)\\vee P(x_2) \\vee \\cdots \\vee P(x_n)\n\\end{align*}\\]\nLa quantification universelle \\(\\forall\\ x\\ P(x)\\) est vraie quand \\(P(x)\\) est vraie pour toutes les valeurs de \\(x\\) dans l’univers du discours \\(U\\). Elle est donc fausse s’il existe un \\(x\\) de \\(U\\) pour lequel \\(P(x)\\) est fausse. Un tel élément est appelé un contre-exemple de \\(\\forall\\ x\\ P(x)\\).\nLa quantification existentielle \\(\\exists\\ x\\ P(x)\\) est vraie s’il existe au moins une valeur \\(x\\) dans l’univers du discours telle que \\(P(x)\\) est vraie. Elle est fausse si \\(P(x)\\) est fausse pour toutes les valeurs possibles de \\(x\\).\nAinsi, pour prouver un énoncé de la forme \\(\\forall\\ x\\ P(x)\\) est vrai, fournir un exemple de \\(x\\) tel que \\(P(x)\\) est vrai ne suffit pas. Il faut montrer que la proposition \\(P(x)\\) est vraie pour toutes les valeurs de \\(x\\), ce qui peut s’avérer particulièrement difficile lorsque \\(U\\) est un ensemble infini. Il en va de même losqu’on veut prouver qu’un énoncé de la forme \\(\\exists\\ x\\ P(x)\\) est faux.\n\n\nTable 3.4: Comment prouver qu’un énoncé quantifié est vrai ou faux quand l’univers du discours \\(U\\) est infini.\n\n\n\n\n\n\n\nPour prouver que\nest vrai\nest faux\n\n\n\n\n\\(\\exists\\ x\\ P(x)\\)\nil suffit de fournir un exemple: un \\(x\\) de \\(U\\) tel que \\(P(x)\\) est vrai.\nil faut fournir un argument général pour montrer que \\(P(x)\\) est faux quel que soit \\(x\\) de \\(U\\).\n\n\n\\(\\forall\\ x\\ P(x)\\)\nil faut fournir un argument général pour montrer que $P(x) est vrai quel que soit \\(x\\) de \\(U\\).\nil suffit de fournir un contre-exemple: un \\(x\\) de \\(U\\) tel que \\(P(x)\\) est faux.\n\n\n\n\n\nExemple 3.11 Si l’univers du discours est l’ensemble des nombres réels et \\[\\begin{align*}\n&P(x)\\ \\text{désigne}\\ x\\geq 0 \\\\\n&Q(x)\\ \\text{désigne}\\ x\\ \\text{est un nombre premier} \\\\\n&R(x)\\ \\text{désigne}\\ 3^x+4^x=5^x \\\\\n&S(x)\\ \\text{désigne}\\ x\\geq 100\n\\end{align*}\\] dites si chacun des énoncés suivants est une proposition vraie, une proposition fausse ou n’est pas une proposition. Donnez un exemple ou un contre-exemple le cas échéant. Dans le cas contraire, indiquez qu’un argument général est requis.\n\n\\(\\forall\\ x\\ P(x)\\)\n\\(\\forall\\ x\\ \\lnot P(x)\\)\n\\(\\forall\\ x\\ P(x^2)\\)\n\\(\\exists\\ x\\ P(x)\\)\n\\(\\exists\\ x\\ \\lnot P(x)\\)\n\\(\\exists\\ x\\ Q(x)\\)\n\\(\\exists\\ x\\ Q(x^2)\\)\n\\(\\forall\\ x\\ R(x)\\)\n\\(P(x)\\)\n\\(\\forall\\ x\\ (S(x)\\rightarrow P(x))\\)\n\\((\\forall\\ x\\ P(x)) \\rightarrow (\\forall\\ x\\ S(x))\\)\n\\(\\forall\\ x\\ S(x+100)\\)\n\\(\\forall\\ x\\ S(x^2+100)\\)\n\n\n\nThéorème 3.1 (Lois de De Morgan pour les quantificateurs) \\[\n\\lnot \\exists\\ x\\ P(x) \\equiv \\forall\\ x\\ \\lnot P(x) \\qquad \\lnot \\forall\\ x\\ P(x) \\equiv \\exists\\ x\\ \\lnot P(x)\n\\]\n\n\nExemple 3.12 Si l’univers du discours est l’ensemble des étudiants du programme Sciences Informatique et Mathématique (ScIM) et \\(M(x)\\) désigne l’énoncé l’étudiant \\(x\\) peut modifier les fichiers du répertoire \\(U\\), traduisez clairement les propositions suivantes à l’aide des quantificateurs.\n\nTous les étudiants de ScIM peuvent modifier les fichiers du répertoire \\(U\\).\nIl est faux que tous les étudiants de ScIM peuvent modifier les fichiers du répertoire \\(U\\).\nAu moins un étudiant de ScIM peut modifier les fichiers du répertoire \\(U\\).\nIl est faux qu’au moins un étudiant de ScIM peut modifier les fichiers du répertoire \\(U\\).\nAucun étudiant de ScIM ne peut modifier les fichiers du répertoire \\(U\\).\nAu moins un étudiant de ScIM ne peut pas modifier les fichiers du répertoire \\(U\\).\n\nDe plus, déterminez les propositions ci-dessus qui sont équivalentes.\n\n\nExemple 3.13 Si l’univers du discours est l’ensemble des billes contenues dans un bol, et si\n\n\\(G(x)\\) désigne la bille \\(x\\) est grosse\n\\(J(x)\\) désigne la bille \\(x\\) est jaune\n\\(R(x)\\) désigne la bille \\(x\\) est rouge\n\\(B(x)\\) désigne la bille \\(x\\) est bleue\n\ntraduisez clairement les propositions suivantes en prenant soin de bien formuler les phrases.\n\n\\(\\forall\\ x\\ (R(x) \\vee J(x))\\)\n\\((\\forall\\ x\\ R(x)) \\vee (\\forall\\ x\\ J(x))\\)\nLes propositions a. et b. sont-elles équivalentes?\n\\(\\exists\\ x\\ B(x)\\)\n\\(\\lnot(\\exists\\ x\\ B(x))\\)\nUtilisez le quantificateur universel \\(\\forall\\) pour écrire une proposition équivalente à la précédente.\n\\(\\lnot(\\forall\\ x\\ R(x))\\)\nUtilisez le quantificateur existentiel \\(\\exists\\) pour écrire une proposition équivalente à la précédente.\n\\(\\forall\\ x\\ (G(x) \\rightarrow B(x))\\)\n\\(\\exists\\ x\\ (G(x) \\wedge B(x))\\)\n\\((\\exists\\ x\\ G(x)) \\wedge (\\exists\\ x\\ B(x))\\)\nLes deux propositions précédentes sont-elles équivalentes?\nLes deux propositions suivantes sont-elles équivalentes? \\[\n(\\exists\\ x\\ R(x)) \\vee (\\exists\\ x\\ J(x)) \\qquad \\text{et} \\qquad \\exists\\ x\\ (R(x) \\vee J(x))\n\\]\nLes deux propositions suivantes sont-elles équivalentes? \\[\n(\\forall\\ x\\ R(x)) \\wedge (\\forall\\ x\\ G(x)) \\qquad \\text{et} \\qquad \\forall\\ x\\ (R(x) \\wedge G(x))\n\\]"
  },
  {
    "objectID": "logique.html#opérations-bit-à-bit",
    "href": "logique.html#opérations-bit-à-bit",
    "title": "3  Logique",
    "section": "3.4 Opérations bit à bit",
    "text": "3.4 Opérations bit à bit"
  },
  {
    "objectID": "logique.html#problèmes-de-logique",
    "href": "logique.html#problèmes-de-logique",
    "title": "3  Logique",
    "section": "3.5 Problèmes de logique",
    "text": "3.5 Problèmes de logique\nLes problèmes suivants se déroulent sur une île imaginaire où tous les habitants sont soit des chevaliers, qui disent toujours la vérité, soit des fripons, qui mentent toujours. Ces énigmes implique un visiteur qui rencontre un petit groupe d’habitants de l’île. La plupart du temps, le but du visiteur est de déduire les types des habitants à partir de leurs énoncés.\nVoici un exemple type de problème possible.\n\n\n\n\n\n\nDéduisez!\n\n\n\nEn vous promenant sur l’île, vous rencontrez trois habitants gardant un pont. Pour passer, vous devez déduire le type de chaque habitant. Chaque individu dit un seul énoncé:\n\nIndividu A: Si je suis un fripon, alors il y a exactement deux chevaliers ici.\nIndividu B: L’individu A ment.\nIndividu C: Soit nous sommes tous des fripons ou alors au moins l’un d’entre nous est un chevalier.\n\nQuels sont les types des trois individus?\n\n\n\nStratégies\nVoici quelques stratégies que vous pouvez utiliser pour résoudre ce genre de problème:\n\nCommencez en supposant qu’un individu est d’un certain type. Soyez stratégique avec votre supposition, tentez de résoudre un énoncé ET.\n\nSi un individu dit ET, supposez qu’il est un chevalier;\nSi un individu dit OU, supposez qu’il est un fripon;\nSi un individu dit SI/ALORS, supposez qu’il est un fripon;\nSi un individu dit SI ET SEULEMENT SI, attendez de connaître la valeur de vérité de leur énoncé avant de faire une supposition.\n\nLorsqu’un individu est un chevalier, vous pouvez continuer leur énoncé.\nLorsqu’un individu est un fripon, vous pouvez continuer la négation de leur énoncé.\n\nPartie 1 ET Partie 2 \\(\\rightarrow\\) NON Partie 1 OU NON Partie 2\nPartie 1 OU Partie 2 \\(\\rightarrow\\) NON Partie 1 ET NON Partie 2\nSI Partie 1, alors Partie 2 \\(\\rightarrow\\) Partie 1 ET NON Partie 2\n\nSoyez prudents avec les si et seulement si\n\nLorsqu’un si et seulement si est VRAI, alors les deux parties ont la même valeur de vérité.\nLorsqu’un si et seulement si est FAUX, alors les deux parties ont des valeurs de vérités différentes.\n\nLorsque vous avez prouvé l’identité d’un individu, vous pouvez utiliser cette information partout dans le reste de l’énigme.\nSi vous avez suffisament d’information pour confirmer que l’énoncé d’un individu est VRAI, alors ils doivent être un chevalier.\nSi vous avez suffisament d’information pour confirmer que l’énoncé d’un individu est FAUX, alors ils doivent être un fripon.\n\n\n\n3.5.1 Trois énoncés différents\nNous pouvons, dans la plupart des problèmes, regrouper les énoncés des habitants de l’île en trois formes distinctes.\n\n3.5.1.1 Accusations et affirmations\nDans une accusation, un habitant A dit par exemple B est un fripon ou un énoncé équivalent comme B ment toujours. Dans une affirmation, l’habitant A dit par exemple B est un chevalier ou alors B dit toujours la vérité.\n\nExemple 3.14 Que pouvez-vous conclure si A et B sont reliés par une accusation?\n\n\nExemple 3.15 Que pouvez-vous conclure si A et B sont reliés par une affirmation?\n\n\n\n3.5.1.2 Conjonctions de fripons\nUn exemple de conjonction de fripons est lorsque A dit que B est un chevalier ou je suis un fripon, ou alors C est un fripon et je suis un fripon\n\nExemple 3.16 Que pouvez-vous conclure si A et B sont reliés par ou je suis un fripon?\n\n\nExemple 3.17 Que pouvez-vous conclure si A et B sont reliés par et je suis un fripon?\n\n\n\n3.5.1.3 Énoncés de différences ou de similarités\nParfois un habitant A dira B est de mon type ou peut-être C n’est pas de mon type.\n\nExemple 3.18 Que pouvez-vous conclure si A dit que B est de son type?\n\n\nExemple 3.19 Que pouvez-vous conclure si A dit que C n’est pas de son type?\n\nIl est intéressant de comparer ces énoncés avec ceux d’accusations et d’affirmations. Ces deux types d’énoncés sont réciproques en quelque sorte. Lorsqu’un habitant dit directement de quel type est un autre habitant (dans une accusation ou une affirmation), tout ce qu’on apprend c’est que la source et la cible sont similaires ou différents, sans apprendre leur type. Par contre, lorsqu’un habitant dit un énoncé par rapport aux similitudes ou aux différences, nous apprenons exactement de quel type la cible est, sans apprendre si elle est similaire ou différente de la source.\n\nExemple 3.20 Vous rencontrez trois habitants de l’île.\n\nA dit: B ne ment jamais.\nA dit: C est un chevalier ou je suis un fripon.\n\n\n\nExemple 3.21 Vous rencontrez trois habitants de l’île.\n\nA dit: B ment toujours.\nB dit: A n’est pas de mon type."
  },
  {
    "objectID": "ensembles.html#notions-de-base-sur-les-ensembles",
    "href": "ensembles.html#notions-de-base-sur-les-ensembles",
    "title": "4  Théorie des ensembles",
    "section": "4.1 Notions de base sur les ensembles",
    "text": "4.1 Notions de base sur les ensembles\n\nDéfinition 4.1 (Ensemble, élément) Un ensemble est un collection non ordonnée d’objets. Les objets sont appelés éléments de l’ensemble et on dit qu’ils appartiennent à l’ensemble.\nNotation : \\(x\\in F\\) signifie que \\(x\\) est un élément de l’ensemble \\(F\\). On dit aussi que \\(x\\) appartient à l’ensemble \\(F\\).\n\n\nDéfinition 4.2 (Ensemble fini ou infini, cardinalité) Soit \\(A\\) un ensemble composé de \\(n\\) éléments distincts. On dit que \\(A\\) est un ensemble fini de cardinalité \\(n\\) et on note \\(|A|=n\\). Un ensemble est dit infini s’il n’est pas fini.\n\n\nExemple 4.1 Soit l’ensemble \\(F=\\set{2,\\pi,7}\\). Utilisez les symboles introduits pour traduire les énoncés suivants: l’ensemble \\(F\\) contient 3 éléments, \\(\\pi\\) appartient à \\(F\\), 5 n’appartient pas à \\(F\\).\n\nOn peut décrire un ensemble en extension (on énumère ses éléments que l’on place entre accolades) \\[\nA=\\set{5,7,9,11} \\qquad B=\\set{1,8,27,64}\n\\] ou en compréhension, comme ceci: \\[\nA=\\set{x\\in\\mathbb{N}\\mid (x\\ \\text{est impair}) \\wedge (5\\leq x \\leq 11)} \\qquad\nB=\\set{x\\in\\mathbb{N}\\mid (x \\leq 64) \\wedge (\\exists\\ y\\in \\mathbb{N},\\ y^3=x)}\n\\]\nPour créer un ensemble dans Python, nous allons utiliser une paire d’accolades { } et placer les différents éléments de notre ensemble entre ces accolades en les séparant avec une virgule. De plus, nous pouvons vérifier si un élément appartient à l’ensemble en utilisant la commande in.\n\nA={-2,0,1,4}\nprint(A, 1 in A, 5 in A)\n\n{0, 1, 4, -2} True False\n\n\nPour calculer la cardinalité d’un ensemble dans Python, vous utilisez la fonction len(). En Python, il faut être prudent si on souhaite utiliser l’ensemble vide, \\(\\emptyset\\). Si vous utilisez {} pour décrire l’ensemble vide, Python va plutôt l’interpréter comme un dictionnaire vide. Vous devez plutôt utiliser la fonction set().\n\nA = {2,3,5,8}\nB = set()\nC = {0}\nprint(len(A), len(B), len(C))\n\n4 0 1"
  },
  {
    "objectID": "ensembles.html#ensembles-de-nombres-mathbbn-mathbbz-mathbbq-mathbbr",
    "href": "ensembles.html#ensembles-de-nombres-mathbbn-mathbbz-mathbbq-mathbbr",
    "title": "4  Théorie des ensembles",
    "section": "4.2 Ensembles de nombres \\(\\mathbb{N}\\), \\(\\mathbb{Z}\\), \\(\\mathbb{Q}\\), \\(\\mathbb{R}\\)",
    "text": "4.2 Ensembles de nombres \\(\\mathbb{N}\\), \\(\\mathbb{Z}\\), \\(\\mathbb{Q}\\), \\(\\mathbb{R}\\)\nNous détaillerons dans la Table 4.1, les ensembles de nombres les plus communs.\n\n\nTable 4.1: Ensembles de nombres usuels.\n\n\n\n\n\n\nEnsemble\nDescription\n\n\n\n\n\\(\\emptyset = \\set{\\phantom{1}}\\)\nEnsemble vide (ne contient aucun élément \\(\\mid\\emptyset\\mid=0\\))\n\n\n\\(\\mathbb{N}=\\set{0,1,2,3,\\ldots}\\)\nEnsemble des nombres naturels\n\n\n\\(\\mathbb{N^*}=\\set{1,2,3,\\ldots}\\)\nEnsemble des nombres naturels strictement positifs\n\n\n\\(\\mathbb{Z}=\\set{\\ldots,-2,-1,0,1,2,\\ldots}\\)\nEnsemble des nombres entiers\n\n\n\\(\\mathbb{Z^*}=\\set{\\ldots,-2,-1,1,2,\\ldots}\\)\nEnsemble des entiers non nuls\n\n\n\\(\\mathbb{Q}=\\set{\\frac{p}{q}\\mid p\\in\\mathbb{Z},q\\in\\mathbb{Z}\\ \\text{et}\\ q\\neq 0}\\)\nEnsemble des nombres rationnels\n\n\n\\(\\mathbb{R}\\)\nEnsemble des nombres réels\n\n\n\\(\\mathbb{R^+}=\\set{x\\in\\mathbb{R}\\mid x\\geq 0}\\)\nEnsemble des nombres réels positifs\n\n\n\\(\\mathbb{C}=\\set{a+bi\\mid a\\in \\mathbb{R}\\ \\text{et}\\ b\\in\\mathbb{R}}\\) avec \\(i^2=-1\\)\nEnsemble des nombres complexes\n\n\n\n\n\nExemple 4.2 Établissez un lien entre les ensembles décrits par compréhension aux parties a. à f. avec le même ensemble décrit par extension aux parties 1 à 6.\n\n\\(\\set{x\\in\\mathbb{Z}\\mid x^2=1}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid x^3=1}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid |x|\\leq 2}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid x^2 \\leq 4}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid x&lt;|x|}\\)\n\\(\\set{x\\in\\mathbb{Z}\\mid (x+1)^2=x^2+2x+1}\\)\n\n\n\\(\\set{-1,0,1}\\)\n\\(\\set{\\ldots,-3,-2,-1,0,1,2,3,\\ldots}\\)\n\\(\\set{1}\\)\n\\(\\set{\\ldots,-3,-2,-1}\\)\n\\(\\set{-1,1}\\)\n\\(\\set{-2,-1,0,1,2}\\)\n\n\n\n\n\n\n\n\nNote\n\n\n\nLorsqu’il y a trop d’éléments dans un ensemble pour être en mesure de tous les écrire, nous utilisons souvent les trois-points (\\(\\ldots\\)) lorsque la suite d’éléments est claire. Par exemple, nous avons: \\[\n\\mathbb{Z}=\\set{\\ldots,-3,-2,-1,0,1,2,3,\\ldots}\n\\]\n\n\nEn Python, si vous avez un ensemble décrit par compréhension, il est particulièrement facile de le créer avec une compréhension de liste. L’idée est simple: simplifier le code pour le rendre plus lisible et donc plus rapide à écrire et plus simple à maintenir. La syntaxe est la suivante:\nnew_list = [function(item) for item in list if condition(item)]\nnew_list = {function(item) for item in list if condition(item)}\nPar exemple, si vous voulez créer l’ensemble \\(\\set{x^3\\mid 0\\leq x &lt; 10}\\), nous pouvons le faire en Python de la manière suivante:\n\nensemble = {x**3 for x in range(10)}\nliste = [x**3 for x in range(10)]\nprint(ensemble, liste)\n\n{0, 1, 64, 512, 8, 343, 216, 729, 27, 125} [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez que dans l’ensemble, les éléments ne sont pas ordonnés, tandis qu’ils le sont dans la liste.\n\n\n\nDéfinition 4.3 (Égalité d’ensembles) Deux ensembles sont dits égaux si et seulement s’ils contiennent exactement les mêmes éléments. \\[\nA=B \\leftrightarrow \\forall\\ x\\ (x\\in A \\leftrightarrow x\\in B)\n\\]\n\n\nExemple 4.3 Les ensembles suivants sont-ils égaux? \\[\\begin{align*}\n\\set{1,3,5} &\\stackrel{?}{=} \\set{3,5,1} \\\\\n\\set{1,3,5} &\\stackrel{?}{=} \\set{\\set{1},\\set{3},\\set{5}}\n\\end{align*}\\]\n\n\nDéfinition 4.4 (Sous-ensemble) L’ensemble \\(A\\) est sous-ensemble de l’ensemble \\(B\\) si et seulement si tous les éléments de \\(A\\) sont aussi des éléments de \\(B\\): \\[\nA \\subseteq B \\leftrightarrow \\forall\\ x\\ (x\\in A \\rightarrow x\\in B)\n\\] L’ensemble \\(A\\) est sous-ensemble strict (ou propre) de l’ensemble \\(B\\) si et seulement si tous les éléments de \\(A\\) sont aussi des éléments de \\(B\\) et \\(A\\) n’est pas égal à \\(B\\): \\[\nA \\subset B \\leftrightarrow A\\subseteq B \\wedge\\ A\\neq B\n\\]\n\n\nExemple 4.4 Convainquez-vous des affirmations suivantes. \\[\\begin{align*}\n\\set{1,2} &\\subseteq \\set{1,2,3,4,5} \\\\\n\\set{1,2} &\\subset \\set{1,2,3,4,5} \\\\\n\\set{2k\\mid k\\in\\mathbb{N}} &= \\set{0,2,4,6,\\ldots}\\subset\\mathbb{N}\n\\end{align*}\\]\n\n\n\nTable 4.2: Notation de la théorie des ensembles.\n\n\n\n\n\n\nNotation\nDescription\n\n\n\n\n\\(\\in\\)\n\\(2\\in\\set{1,2,3}\\) indique que 2 est un élément de l’ensemble \\(\\set{1,2,3}\\).\n\n\n\\(\\not\\in\\)\n\\(4\\not\\in\\set{1,2,3}\\) indique que 4 n’est pas un élément de l’ensemble \\(\\set{1,2,3}\\).\n\n\n\\(\\subseteq\\)\n\\(A\\subseteq B\\) indique que \\(A\\) est un sous-ensemble de \\(B\\): chaque élément de \\(A\\) est aussi un élément de \\(B\\).\n\n\n\\(\\subset\\)\n\\(A\\subset B\\) indique que \\(A\\) est un sous-ensemble propre de \\(B\\): chaque élément de \\(A\\) est aussi un élément de \\(B\\), mais \\(A\\neq B\\).\n\n\n\n\n\nThéorème 4.1 Pour tout ensemble \\(A\\), on a :\n\n\\(\\emptyset\\subseteq A\\)\n\\(A\\subseteq A\\)\n\n\n\nThéorème 4.2 \\(A=B\\) si et seulement si \\(A\\subseteq B\\) et \\(B\\subseteq A\\).\n\nEn Python, nous pouvons utiliser la fonction issubset pour vérifier qu’un ensemble est sous-ensemble d’un autre.\n\nA = {2,4,6,8,10,12}\nB = {4,8,12}\nprint(A.issubset(B), B.issubset(A))\n\nFalse True"
  },
  {
    "objectID": "ensembles.html#produit-cartésien",
    "href": "ensembles.html#produit-cartésien",
    "title": "4  Théorie des ensembles",
    "section": "4.3 Produit cartésien",
    "text": "4.3 Produit cartésien\n\nDéfinition 4.5 (Produit cartésien) Le produit cartésien des ennsembles \\(A\\) et \\(B\\), noté \\(A\\times B\\), est L’ensemble de tous les couples (paires ordonnées) dont le premier élément appartient à \\(A\\) et le second, à \\(B\\): \\[\nA\\times B = \\set{(a,b)\\mid\\ a\\in A\\ \\text{et}\\ b\\in B}\n\\] On généralise cette définition au produit cartésien de \\(n\\) ensembles: \\[\nA_1 \\times A_2 \\times \\ldots \\times A_n = \\set{(a_1,a_2,\\ldots,a_n)\\mid\\ a_1\\in A_1,\\ldots, a_n\\in A_n}\n\\]\n\n\nExemple 4.5 Décrivez en extension les produits cartésiens \\(A\\times B\\) et \\(B\\times A\\), où \\(A=\\set{0,1,2}\\) et \\(B=\\set{a,c}\\).\n\n\nDéfinition 4.6 (Relation) Une relation entre les ensembles \\(A\\) et \\(B\\) est un sous-ensemble du produit cartésien \\(A\\times B\\).\n\n\nExemple 4.6 Soit $A= et $B=. L’ensemble \\[\nR=\\set{(0,a),(1,c),(2,a)}\\subseteq A\\times B\n\\] est une relation de \\(A\\) dans \\(B\\).\n\n\nDéfinition 4.7 L’ensmeble des parties de \\(A\\), noté \\(\\mathcal{P}(A)\\), est l’ensemble de tous les sous-ensembles de \\(A\\). \\[\nB\\in \\mathcal{P}(A) \\leftrightarrow B \\subseteq A\n\\]\n\n\nExemple 4.7 Décrivez \\(\\mathcal{P}(A)\\), l’ensemble des parties de \\(A\\), où \\(A=\\set{0,1,2}\\).\n\n\n\n\n\n\n\n\n\\(k\\)\nSous-ensembles de \\(A\\) ayant \\(k\\) éléments\nNombre de sous-ensembles\n\n\n\n\n0\n\\(\\emptyset\\)\n1\n\n\n1\n\\(\\set{0}\\), \\(\\set{1}\\), \\(\\set{2}\\)\n3\n\n\n2\n\\(\\set{0,1}\\), \\(\\set{0,2}\\), \\(\\set{1,2}\\)\n3\n\n\n3\n\\(\\set{0,1,2}\\)\n1\n\n\n\n\n\nExemple 4.8 Décrivez \\(\\mathcal{P}(A)\\), l’ensemble des parties de \\(A\\), où \\(A=\\set{0,1,2,3}\\).\n\n\n\n\n\n\n\n\n\\(k\\)\nSous-ensembles de \\(A\\) ayant \\(k\\) éléments\nNombre de sous-ensembles\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4"
  },
  {
    "objectID": "ensembles.html#opérations-sur-les-ensembles-cap-cup-oplus--",
    "href": "ensembles.html#opérations-sur-les-ensembles-cap-cup-oplus--",
    "title": "4  Théorie des ensembles",
    "section": "4.4 Opérations sur les ensembles \\(\\cap\\), \\(\\cup\\), \\(\\oplus\\), \\(-\\)",
    "text": "4.4 Opérations sur les ensembles \\(\\cap\\), \\(\\cup\\), \\(\\oplus\\), \\(-\\)\nSoit \\(U\\) l’ensemble universel et \\(A\\) et \\(B\\) des sous-ensembles de \\(U\\). Les opérations suivantes génèrent des sous-ensembles de \\(U\\).\n\n\nTable 4.3: Les diverses opérations sur les ensembles.\n\n\n\n\n\n\nOpération\nForme mathématique\n\n\n\n\nUnion\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\vee\\ x\\in B}\\)\n\n\nIntersection\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\wedge\\ x\\in B}\\)\n\n\nDifférence\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\wedge\\ x\\not\\in B}=A\\setminus B\\)\n\n\nDifférence symétrique\n\\(\\set{x\\in U\\mid\\ x\\in A\\ \\oplus\\ x\\in B}\\)\n\n\nComplément\n\\(\\set{x\\in U\\mid\\ x\\not\\in A}=U-A\\)\n\n\n\n\n\n\n\n\n\n\nUnion\n\n\n\n\n\n\n\nIntersection\n\n\n\n\n\n\n\n\n\nDifférence\n\n\n\n\n\n\n\nDifférence symétrique\n\n\n\n\n\n\n\n\n\nComplément\n\n\n\n\n\nVous pouvez effectuer ces opérations dans Python à l’aide des commandes suivantes:\n\n\nTable 4.4: Les opérations sur les ensembles dans Python.\n\n\nOpération\nCommande Python\n\n\n\n\nUnion\nunion\n\n\nIntersection\nintersection\n\n\nDifférence\ndifference\n\n\n\n\n\nA = {-3,-1,2,5}\nB = {-1, 0, 2}\nprint(A.union(B))\n\n{0, 2, 5, -3, -1}\n\n\n\nA = {-3,-1,2,5}\nB = {-1, 0, 2}\nprint(A.intersection(B))\n\n{2, -1}\n\n\n\nA = {-3,-1,2,5}\nB = {-1, 0, 2}\nprint(A.difference(B))\n\n{5, -3}"
  },
  {
    "objectID": "ensembles.html#représentation-de-sous-ensembles-par-trains-de-bits",
    "href": "ensembles.html#représentation-de-sous-ensembles-par-trains-de-bits",
    "title": "4  Théorie des ensembles",
    "section": "4.5 Représentation de sous-ensembles par trains de bits",
    "text": "4.5 Représentation de sous-ensembles par trains de bits"
  },
  {
    "objectID": "ensembles.html#polygones-convexes-avec-des-opérations-sur-les-ensembles",
    "href": "ensembles.html#polygones-convexes-avec-des-opérations-sur-les-ensembles",
    "title": "4  Théorie des ensembles",
    "section": "4.6 Polygones convexes avec des opérations sur les ensembles",
    "text": "4.6 Polygones convexes avec des opérations sur les ensembles"
  },
  {
    "objectID": "fonctions.html#fonctions-plancher-et-plafond",
    "href": "fonctions.html#fonctions-plancher-et-plafond",
    "title": "5  Fonctions",
    "section": "5.1 Fonctions plancher et plafond",
    "text": "5.1 Fonctions plancher et plafond\n\nDéfinition 5.2 (Fonctions plancher et plafond) La fonction plancher associe à tout nombre réel \\(x\\), le plus grand entier \\(n\\) tel que \\(n\\leq x\\). On note \\(\\lfloor x\\rfloor = n\\). La fonction plafond associe à tout nombre réel \\(x\\), le plus petit entier \\(n\\) tel que \\(n\\geq x\\). On note \\(\\lceil x \\rceil = n\\).\n\n\nExemple 5.2 Calculez les fonctions suivantes: \\[\\begin{align*}\n\\left\\lfloor \\frac{1}{3}\\right\\rfloor &= \\\\\n\\left\\lceil \\frac{1}{3}\\right\\rceil &= \\\\\n\\left\\lfloor -9,2\\right\\rfloor &= \\\\\n\\left\\lceil -9,2\\right\\rceil &= \\\\\n\\end{align*}\\]\n\n\nThéorème 5.1 (Propriétés des fonctions plancher et plafond)  \n\n\\(\\lfloor x\\rfloor = n\\) \\(\\leftrightarrow\\) \\(n\\leq x&lt;n+1\\)\n\\(\\lceil x\\rceil = n\\) \\(\\leftrightarrow\\) \\(n-1&lt; x\\leq n\\)\n\\(x-1&lt;\\lfloor x\\rfloor \\leq x \\leq \\lceil x \\rceil &lt; x+1\\)\n\n\nLa Figure 5.1 présente le graphique des fonctions plancher et plafond.\n\n\n\n\n\n\n\nFonction plancher\n\n\n\n\n\n\n\nFonction plafond\n\n\n\n\nFigure 5.1: Les fonctions plancher et plafond.\n\n\nCes deux fonctions sont accessibles dans Python en utilisant la librairie math, sous le nom de floor (fonction plancher) et ceil (fonction plafond).\n\nimport math\n\nprint(\"Résultats de la fonction plafond\")\nprint(math.ceil(1.4))\nprint(math.ceil(5.3))\nprint(math.ceil(-5.3))\nprint(math.ceil(22.6))\nprint(math.ceil(10.0))\n\nprint(\"Résultats de la fonction plancher\")\nprint(math.floor(1.4))\nprint(math.floor(5.3))\nprint(math.floor(-5.3))\nprint(math.floor(22.6))\nprint(math.floor(10.0))\n\nRésultats de la fonction plafond\n2\n6\n-5\n23\n10\nRésultats de la fonction plancher\n1\n5\n-6\n22\n10"
  },
  {
    "objectID": "fonctions.html#fonctions-en-python",
    "href": "fonctions.html#fonctions-en-python",
    "title": "5  Fonctions",
    "section": "5.2 Fonctions en Python",
    "text": "5.2 Fonctions en Python\nDEVRAIT-ON PARLER DE ÇA????\nDICTIONNAIRE, HACHAGE…\n\nExemple 5.3 Fonction de hachage dans Python\nHachage Python\nDictionnary in Python\nA checksum is used to determine if something is the same.\nIf you have download a file, you can never be sure if it got corrupted on the way to your machine. You can use cksum to calculate a checksum (based on CRC-32) of the copy you now have and can then compare it to the checksum the file should have. This is how you check for file integrity.\nA hash function is used to map data to other data of fixed size. A perfect hash function is injective, so there are no collisions. Every input has one fixed output.\nA cryptographic hash function is used for verification. With a cryptographic hash function you should to not be able to compute the original input.\nA very common use case is password hashing. This allows the verification of a password without having to save the password itself. A service provider only saves a hash of a password and is not able to compute the original password. If the database of password hashes gets compromised, an attacker should not be able to compute these passwords as well. This is not the case, because there are strong and weak algorithms for password hashing. You can find more on that on this very site.\nTL;DR:\nChecksums are used to compare two pieces of information to check if two parties have exactly the same thing.\nHashes are used (in cryptography) to verify something, but this time, deliberately only one party has access to the data that has to be verified, while the other party only has access to the hash."
  },
  {
    "objectID": "fonctions.html#injection-surjection-et-bijection",
    "href": "fonctions.html#injection-surjection-et-bijection",
    "title": "5  Fonctions",
    "section": "5.3 Injection, surjection et bijection",
    "text": "5.3 Injection, surjection et bijection\n\nDéfinition 5.3 (Fonction injective, surjective, bijective) Soit \\(f:A\\rightarrow B\\) une fonction. On dit que\n\n\\(f\\) est injective si elle n’associe jamais la même image à deux éléments distincts: \\[\n\\forall\\ a_1 \\in A,\\ \\forall\\ a_2 \\in A,\\ (a_1\\neq a_2) \\rightarrow (f(a_1) \\neq f(a_2))\n\\]\n\\(f\\) est surjective si son image est l’ensemble \\(B\\) au complet, c’est-à-dire si tous les éléments de \\(B\\) sont atteints: \\[\n\\forall\\ b\\in B,\\ \\exists\\ a \\in A,\\ f(a)=b\n\\]\n\\(f\\) est bijective si elle est injective et surjective: \\[\n\\forall\\ b\\in B,\\ \\exists! a\\in A,\\ f(a)=b\n\\]\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSi une fonction n’est pas injective, alors elle ne possède pas d’inverse.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSi une fonction n’est pas surjective, alors elle ne possède pas d’inverse.\n\n\n\nExemple 5.4 On considère un sous-ensemble \\(f\\) du produit cartésien de deux ensembles. Dans chaque cas, tracez son graphe saggital puis déterminez s’il s’agit d’une fonction ou non. De plus, si \\(f\\) est une fonction, déterminez si elle est injective, surjective ou bijective.\nIci, \\(L=\\set{a,b,c,d,e}\\), \\(M=\\set{a,b,c}\\), \\(C=\\set{1,2,3,4}\\) et \\(D=\\set{1,2,3}\\).\n\n\\(f=\\set{(1,a),(2,d),(3,c),(4,e)}\\subseteq C \\times L\\)\n\\(f=\\set{(1,a),(2,a),(3,c),(4,b)}\\subseteq C \\times M\\)\n\\(f=\\set{(1,a),(2,d),(3,c),(4,e),(1,b)}\\subseteq C \\times L\\)\n\\(f=\\set{(1,c),(2,a),(3,a),(4,a)}\\subseteq D \\times M\\)\n\\(f=\\set{(1,a),(2,a),(3,a),(4,a)}\\subseteq C \\times L\\)\n\n\n\nExemple 5.5 La fonction \\(f:\\mathbb{Z}\\times\\mathbb{Z}\\rightarrow \\mathbb{Z}\\) définie par \\(f(x_1,x_2)=x_1+x^2\\) est-elle oui on non injective? Est-elle oui ou non surjective? Est-elle oui ou non bijective?\n\n\n5.3.1 Les dictionnaires dans Python\nLe dictionnaire n’est pas une séquence mais un autre type composite. Ils ressemblent aux listes dans une certaine mesure (ils sont modifiables comme elles), mais les éléments que nous allons y enregistrer ne seront pas disposés dans un ordre immuable. En revanche, nous pourrons accéder à n’importe lequel d’entre eux à l’aide d’un index spécifique que l’on appellera une clé, laquelle pourra être alphabétique, numérique, ou même d’un type composite sous certaines conditions.\n\nExemple 5.6 Dites si le dictionnaire défini ci-dessous est une fonction injective, surjective, ou bijective.\n\njour = {\"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}\ndejeuner = {\"Oeufs\", \"Céréales\", \"Rôties\", \"Gruau\", \"Pâtisserie\", \"Jambon\", \"Crèpes\",\"Saucisses\"}\n\nmydict = {\n    \"Lundi\": \"Oeufs\",\n    \"Mardi\": \"Céréales\",\n    \"Mercredi\": \"Rôties\",\n    \"Jeudi\": \"Gruau\",\n    \"Vendredi\": \"Pâtisserie\",\n    \"Samedi\": \"Jambon\",\n    \"Dimanche\": \"Crèpes\"\n}\n\n\n\nExemple 5.7 Dites si le dictionnaire défini ci-dessous est une fonction injective, surjective, ou bijective.\n\njour = {\"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}\ndejeuner = {\"Oeufs\", \"Céréales\", \"Rôties\", \"Gruau\", \"Pâtisserie\", \"Jambon\", \"Crèpes\",\"Saucisses\"}\n\nmydict = {\n    \"Lundi\": \"Oeufs\",\n    \"Mardi\": \"Oeufs\",\n    \"Mercredi\": \"Rôties\",\n    \"Jeudi\": \"Gruau\",\n    \"Vendredi\": \"Pâtisserie\",\n    \"Samedi\": \"Jambon\",\n    \"Dimanche\": \"Crèpes\"\n}\n\n\n\n\n5.3.2 Fonction de hachage\nUne fonction de hachage est une fonction qui associe des données de taille arbitraire à des valeurs de taille fixe. Les valeurs renvoyées par une fonction de hachage sont appelées valeurs de hachage, codes de hachage, résumés, signatures ou simplement hachages. Les valeurs sont généralement utilisées pour être les indices d’une table de taille raisonnable appelée table de hachage. Le hachage ou adressage de stockage dispersé est donc l’utilisation d’une fonction de hachage pour créer les indices d’une table de hachage.\nLes fonctions de hachage sont utilisées dans les applications de stockage et de récupération de données pour accéder aux données en un temps réduit, en fait quasi-constant. Elles requièrent un espace de stockage à peine plus grand que l’espace total requis pour les données. Ainsi, le hachage est une forme d’accès aux données efficace en termes de calcul et d’espace de stockage.\nL’intérêt des fonctions de hachage repose sur de bonnes propriétés statistiques. En effet, le comportement dans le pire des cas est mauvais, mais il se manifeste avec une probabilité extrêmement faible, en fait négligeable, et le comportement dans le cas moyen est optimal (collision minimale ).\nUne fonction de hachage est typiquement une fonction qui, pour un ensemble de très grande taille (théoriquement infini) et de nature très diversifiée, va renvoyer des résultats aux spécifications précises (en général des chaînes de caractère de taille limitée ou fixe) optimisées pour des applications particulières. Les chaînes permettent d’établir des relations (égalité, égalité probable, non-égalité, ordre…) entre les objets de départ sans accéder directement à ces derniers, en général soit pour des questions d’optimisation (la taille des objets de départ nuit aux performances), soit pour des questions de confidentialité.\nAutrement dit : à 1 fichier (ou à 1 mot) va correspondre une signature unique (le résultat de la fonction de hachage).\n\n\n\n\n\n\nImportant\n\n\n\nDans l’idéal, une fonction de hachage devrait être injective.\n\n\nOn peut trouver le haché d’un élément en Python en utilisant la commande hash. On peut remarquer dans le code ci-dessous que de changer une lettre minuscule en lettre majuscule (le F de fromage) change drastiquement le haché.\n\nphrase1 = \"Maître Corbeau, sur un arbre perché, Tenait en son bec un fromage.\"\nphrase2 = \"Maître Corbeau, sur un arbre perché, Tenait en son bec un Fromage.\"\n\nprint(hex(hash(phrase1)), hex(hash(phrase2)))\n\n-0x1e41e1fa43bb1fa6 -0x6e89943d3308000b"
  },
  {
    "objectID": "notation_grand_o.html#mesurer-un-temps-de-calcul-avec-une-fonction",
    "href": "notation_grand_o.html#mesurer-un-temps-de-calcul-avec-une-fonction",
    "title": "6  Notation grand O",
    "section": "6.1 Mesurer un temps de calcul avec une fonction",
    "text": "6.1 Mesurer un temps de calcul avec une fonction"
  },
  {
    "objectID": "notation_grand_o.html#notation-grand-o",
    "href": "notation_grand_o.html#notation-grand-o",
    "title": "6  Notation grand O",
    "section": "6.2 Notation grand-O",
    "text": "6.2 Notation grand-O"
  },
  {
    "objectID": "notation_grand_o.html#sommations",
    "href": "notation_grand_o.html#sommations",
    "title": "6  Notation grand O",
    "section": "6.3 Sommations",
    "text": "6.3 Sommations"
  },
  {
    "objectID": "notation_grand_o.html#établir-la-complexité-dun-algorithme",
    "href": "notation_grand_o.html#établir-la-complexité-dun-algorithme",
    "title": "6  Notation grand O",
    "section": "6.4 Établir la complexité d’un algorithme",
    "text": "6.4 Établir la complexité d’un algorithme"
  },
  {
    "objectID": "notation_grand_o.html#calculabilité-et-complexité",
    "href": "notation_grand_o.html#calculabilité-et-complexité",
    "title": "6  Notation grand O",
    "section": "6.5 Calculabilité et complexité",
    "text": "6.5 Calculabilité et complexité"
  },
  {
    "objectID": "notation_grand_o.html#p-vs-np",
    "href": "notation_grand_o.html#p-vs-np",
    "title": "6  Notation grand O",
    "section": "6.6 P vs NP",
    "text": "6.6 P vs NP"
  },
  {
    "objectID": "algorithmes.html#bogo-sort",
    "href": "algorithmes.html#bogo-sort",
    "title": "7  Introduction aux algorithmes",
    "section": "7.1 Bogo sort",
    "text": "7.1 Bogo sort\n\nfrom random import shuffle\nfrom random import seed\nfrom random import randint\n\ndef is_sorted(data) -&gt; bool:\n    \"\"\"Determine whether the data is sorted.\"\"\"\n    return all(a &lt;= b for a, b in zip(data, data[1:]))\n\ndef bogosort(data) -&gt; list:\n    \"\"\"Shuffle data until sorted.\"\"\"\n    N = 0\n    while not is_sorted(data):\n        shuffle(data)\n        N = N + 1\n    return data, N\n\nseed(1234)\nN = 8\ndata = [randint(1,10) for x in range(N)]\nbogosort(data)\n\n([1, 1, 2, 2, 2, 2, 8, 10], 1552)"
  },
  {
    "objectID": "algorithmes.html#exemples-dalgorithmes",
    "href": "algorithmes.html#exemples-dalgorithmes",
    "title": "7  Introduction aux algorithmes",
    "section": "7.2 Exemples d’algorithmes",
    "text": "7.2 Exemples d’algorithmes"
  },
  {
    "objectID": "algorithmes.html#fouille-linéaire",
    "href": "algorithmes.html#fouille-linéaire",
    "title": "7  Introduction aux algorithmes",
    "section": "7.3 Fouille linéaire",
    "text": "7.3 Fouille linéaire"
  },
  {
    "objectID": "algorithmes.html#bubble-sort",
    "href": "algorithmes.html#bubble-sort",
    "title": "7  Introduction aux algorithmes",
    "section": "7.4 Bubble sort",
    "text": "7.4 Bubble sort"
  },
  {
    "objectID": "algorithmes.html#insertion-sort",
    "href": "algorithmes.html#insertion-sort",
    "title": "7  Introduction aux algorithmes",
    "section": "7.5 Insertion sort",
    "text": "7.5 Insertion sort"
  },
  {
    "objectID": "algorithmes.html#binary-search",
    "href": "algorithmes.html#binary-search",
    "title": "7  Introduction aux algorithmes",
    "section": "7.6 Binary search",
    "text": "7.6 Binary search"
  },
  {
    "objectID": "algorithmes.html#heap-sort",
    "href": "algorithmes.html#heap-sort",
    "title": "7  Introduction aux algorithmes",
    "section": "7.7 Heap sort",
    "text": "7.7 Heap sort"
  },
  {
    "objectID": "algorithmes.html#complexité-algorithmique",
    "href": "algorithmes.html#complexité-algorithmique",
    "title": "7  Introduction aux algorithmes",
    "section": "7.8 Complexité algorithmique",
    "text": "7.8 Complexité algorithmique"
  },
  {
    "objectID": "theorie_nombres.html#arithmétique-modulaire",
    "href": "theorie_nombres.html#arithmétique-modulaire",
    "title": "8  Théorie des nombres",
    "section": "8.1 Arithmétique modulaire",
    "text": "8.1 Arithmétique modulaire\n\n8.1.1 Division entière\n\n\n8.1.2 Congruence modulo \\(m\\)"
  },
  {
    "objectID": "theorie_nombres.html#entiers-et-algorithmes",
    "href": "theorie_nombres.html#entiers-et-algorithmes",
    "title": "8  Théorie des nombres",
    "section": "8.2 Entiers et algorithmes",
    "text": "8.2 Entiers et algorithmes\n\n8.2.1 Algorithme d’exponentiation modulaire efficace\n\n\n8.2.2 Nombres premiers et PGCD\n\n\n8.2.3 Algorithme d’Euclide et théorème de Bézout\n\n\n8.2.4 Inverse modulo \\(m\\)\n\n\n8.2.5 Résolution de congruence\n\n\n8.2.6 Petit théorème de Fermat"
  },
  {
    "objectID": "theorie_nombres.html#cryptographie-à-clé-secrète",
    "href": "theorie_nombres.html#cryptographie-à-clé-secrète",
    "title": "8  Théorie des nombres",
    "section": "8.3 Cryptographie à clé secrète",
    "text": "8.3 Cryptographie à clé secrète\n\n8.3.1 Chiffrement par décalage\n\n\n8.3.2 Permutation de l’alphabet\n\n\n8.3.3 Masque jetable\n\n\n8.3.4 Chiffrement affine"
  },
  {
    "objectID": "theorie_nombres.html#cryptographie-à-clé-publique",
    "href": "theorie_nombres.html#cryptographie-à-clé-publique",
    "title": "8  Théorie des nombres",
    "section": "8.4 Cryptographie à clé publique",
    "text": "8.4 Cryptographie à clé publique\n\n8.4.1 Chiffrement RSA"
  },
  {
    "objectID": "preuves.html#méthodes-de-preuve",
    "href": "preuves.html#méthodes-de-preuve",
    "title": "9  Preuves et raisonnement mathématique",
    "section": "9.1 Méthodes de preuve",
    "text": "9.1 Méthodes de preuve\n\n9.1.1 Preuve directe\n\nExemple 9.1 LE PRODUIT DE NOMBRES PAIRS ET IMPAIRS\n\n\nExemple 9.2 RACINE DE NOMBRES PAIRS\n\n\nExemple 9.3 PREUVE QUE \\(n^2\\) EST PAIR\n\n\nExemple 9.4 Soit \\(a\\), \\(b\\) et \\(c\\) des entiers. Si \\(a|b\\) et \\(b|c\\) alors \\(a|c\\).\n\n\n\n9.1.2 Preuve indirecte (par contraposée)\n\nExemple 9.5 Montrez que si \\(n^2\\) est pair alors \\(n\\) est pair.\n\n\nExemple 9.6 Montrez que si \\(a+b\\) est impair, alors \\(a\\) est impair ou \\(b\\) est impair.\n\n\nExemple 9.7 Soit \\(p\\) un nombre premier. Si \\(p\\neq 2\\) alors \\(p\\) est impair.\n\n\n\n9.1.3 Preuve par contradiction\n\nExemple 9.8 EXISTE-T-IL UN PLUS PETIT NOMBRE RATIONNEL POSITIF?\n\n\nExemple 9.9 PREUVE QUE \\(\\sqrt{2}\\) EST IRRATIONNEL\n\n\nExemple 9.10 PREUVE QUE QU’IL EXISTE UNE INFINITÉ DE NOMBRES PREMIERS\n\n\nExemple 9.11 Il n’existe pas d’entiers \\(x\\) et \\(y\\) tels que \\(x^2=4y+2\\).\n\n\n\n9.1.4 Principe des tiroirs de Dirichlet\n\nExemple 9.12 (Fonction de hachage) Une fonction de hachage est une fonction qui transforme une suite de bits de longueur arbitraire en une chaîne de longueur fixe. Du fait qu’il y a plus de chaînes possibles en entrée qu’en sortie découle par le principe des tiroirs l’existence de collisions : plusieurs chaînes distinctes ont le même haché. Rendre ces collisions difficiles à déterminer efficacement est un enjeu important en cryptographie."
  },
  {
    "objectID": "preuves.html#principe-de-linduction",
    "href": "preuves.html#principe-de-linduction",
    "title": "9  Preuves et raisonnement mathématique",
    "section": "9.2 Principe de l’induction",
    "text": "9.2 Principe de l’induction\n\n9.2.1 Preuve par récurrence\n\nExemple 9.13 PREUVE QUE \\(1+2+3+\\ldots +n=\\frac{n(n+1)}{2}\\)\n\n\nExemple 9.14 PREUVE QUE \\(n&lt;2^n\\)\n\n\nExemple 9.15 PREUVE QUE 6 EST UN DIVISEUR DE \\(7^n-1\\)\n\n\nExemple 9.16 MONTRER QUE NOUS POUVONS UTILISER DES T-GONES POUR REMPLIR UNE GRILLE \\(2^n \\times 2^n\\)\n\n\nExemple 9.17 MONTRER QUE LA FACTORIELLE CROÎT PLUS RAPIDEMENT QUE L’EXPONENTIELLE\n\n\n\n9.2.2 Algorithmes récursifs\n\n9.2.2.1 Fonctions récursives\n\n\n9.2.2.2 Algorithmes de type diviser pour régner"
  },
  {
    "objectID": "denombrement.html#notions-de-base",
    "href": "denombrement.html#notions-de-base",
    "title": "10  Dénombrement",
    "section": "10.1 Notions de base",
    "text": "10.1 Notions de base"
  },
  {
    "objectID": "denombrement.html#principe-des-nids-de-pigeon-principe-des-tiroirs-de-dirichlet",
    "href": "denombrement.html#principe-des-nids-de-pigeon-principe-des-tiroirs-de-dirichlet",
    "title": "10  Dénombrement",
    "section": "10.2 Principe des nids de pigeon (principe des tiroirs de Dirichlet)",
    "text": "10.2 Principe des nids de pigeon (principe des tiroirs de Dirichlet)"
  },
  {
    "objectID": "denombrement.html#permutations-et-combinaisons",
    "href": "denombrement.html#permutations-et-combinaisons",
    "title": "10  Dénombrement",
    "section": "10.3 Permutations et combinaisons",
    "text": "10.3 Permutations et combinaisons"
  },
  {
    "objectID": "denombrement.html#relations-de-récurrence-et-dénombrement",
    "href": "denombrement.html#relations-de-récurrence-et-dénombrement",
    "title": "10  Dénombrement",
    "section": "10.4 Relations de récurrence et dénombrement",
    "text": "10.4 Relations de récurrence et dénombrement"
  },
  {
    "objectID": "graphes.html#terminologie-et-types-de-graphes",
    "href": "graphes.html#terminologie-et-types-de-graphes",
    "title": "11  Graphes",
    "section": "11.1 Terminologie et types de graphes",
    "text": "11.1 Terminologie et types de graphes"
  },
  {
    "objectID": "graphes.html#représentation-des-graphes",
    "href": "graphes.html#représentation-des-graphes",
    "title": "11  Graphes",
    "section": "11.2 Représentation des graphes",
    "text": "11.2 Représentation des graphes\n\n11.2.1 Représentation par listes d’adjacence\n\n\n11.2.2 Représentation par matrice d’adjacence"
  },
  {
    "objectID": "graphes.html#chemins-dans-un-graphe",
    "href": "graphes.html#chemins-dans-un-graphe",
    "title": "11  Graphes",
    "section": "11.3 Chemins dans un graphe",
    "text": "11.3 Chemins dans un graphe\n\n11.3.1 Chemins, circuits, cycles\n\n\n11.3.2 Dénombrement de chemins\n\n\n11.3.3 Chemins et circuits eulériens\n\n\n11.3.4 Chemins et circuits hamiltoniens"
  },
  {
    "objectID": "graphes.html#problème-du-plus-court-chemin",
    "href": "graphes.html#problème-du-plus-court-chemin",
    "title": "11  Graphes",
    "section": "11.4 Problème du plus court chemin",
    "text": "11.4 Problème du plus court chemin"
  },
  {
    "objectID": "arbres.html#introduction-aux-arbres",
    "href": "arbres.html#introduction-aux-arbres",
    "title": "12  Arbres",
    "section": "12.1 Introduction aux arbres",
    "text": "12.1 Introduction aux arbres"
  },
  {
    "objectID": "arbres.html#applications-des-arbres",
    "href": "arbres.html#applications-des-arbres",
    "title": "12  Arbres",
    "section": "12.2 Applications des arbres",
    "text": "12.2 Applications des arbres"
  },
  {
    "objectID": "arbres.html#parcours-dun-arbre",
    "href": "arbres.html#parcours-dun-arbre",
    "title": "12  Arbres",
    "section": "12.3 Parcours d’un arbre",
    "text": "12.3 Parcours d’un arbre"
  },
  {
    "objectID": "arbres.html#arbres-et-tri",
    "href": "arbres.html#arbres-et-tri",
    "title": "12  Arbres",
    "section": "12.4 Arbres et tri",
    "text": "12.4 Arbres et tri"
  },
  {
    "objectID": "arbres.html#arbres-et-recouvrement",
    "href": "arbres.html#arbres-et-recouvrement",
    "title": "12  Arbres",
    "section": "12.5 Arbres et recouvrement",
    "text": "12.5 Arbres et recouvrement"
  },
  {
    "objectID": "arbres.html#arbres-générateurs-de-coût-minimal",
    "href": "arbres.html#arbres-générateurs-de-coût-minimal",
    "title": "12  Arbres",
    "section": "12.6 Arbres générateurs de coût minimal",
    "text": "12.6 Arbres générateurs de coût minimal"
  }
]