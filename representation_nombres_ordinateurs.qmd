# Représentation des nombres dans l'ordinateur

Lorsque nous voulons représenter des nombres dans un ordinateur, il faut distinguer deux cas biens différents; la représentation des nombres **entiers** et la représentation des nombres **fractionnaires**.

## Représentation des entiers

En `Python`, contrairement à la plupart des langages informatiques, les entiers sont représentés avec une précision **infinie**. C'est-à-dire que la seule limite correspond à la mémoire interne de la machine que vous utilisez. Cependant, dans la majorité des langages informatiques, la précision de la représentation des entiers est **finie**, c'est-à-dire qu'un certain nombre de bits est alloué en mémoire pous stocker votre nombre et vous ne pouvez pas le dépasser.

Nous pouvons connaître le nombre de bits utilisés par `Python` dans la représentation d'un entier en utilisant la fonction `getsizeof` du module `sys`.

```{python}
from sys import getsizeof

n1 = 2**32
n2 = 2**128
print(getsizeof(n1), getsizeof(n2))
```

Pour étudier le comportement d'entiers ayant une taille fixe, on peut utiliser le module `numpy`. Ce module possède plusieurs classes d'entiers à taille fixe.

### Entiers non signés

:::{#def-entiers-non-signes}
## Entiers non signés (nombres positifs)

Un nombre **entier non signé** (positif) est représenté par un nombre de bits préalablement fixé. Au besoin, on complète le nombre par des zéros à gauche fin d'avoir le nombre total de bits choisi.
:::

:::{.callout-tip}
## Les entiers non signés à taille fixe en `Python`

- `numpy.ubyte`: entier non signé sur 8 bits
- `numpy.ushort`: entier non signé sur 16 bits
- `numpy.uintc`: entier non signé sur 32 bits
- `numpy.uint`: entier non signé sur 64 bits

:::

:::{#exm-entiers-non-signes}
Transformez les entiers décimaux suivants en entiers non signés sur un octet (huit bits).

a) 143
a) 15
a) 30
:::

```{python}
import numpy as np

print(bin(np.ubyte(143)), bin(np.ubyte(15)), bin(np.ubyte(30)))
```

:::{.callout-caution}
## Soyez prudents!

Si on tente d'écrire un nombre entier qui dépasse la capacité du format, nous n'obtenons pas nécessairement un message d'erreur, il faut donc être très prudents. Par exemple, le format `numpy.byte` peut représenter les entiers de 0 à 255. Si nous tentons de représenter 256, nous obtenons:

```{python}
import numpy as np

print(np.uint8(256))
```
:::

Ce genre d'erreur est appelée un dépassement d'entier. Un dépassement d'entier (*integer overflow*) est, en informatique, une condition qui se produit lorsqu'une opération mathématique produit une valeur numérique supérieure à celle représentable dans l'espace de stockage disponible. Par exemple, l'ajout d'une unité au plus grand nombre pouvant être représenté entraîne un dépassement d'entier.

Le dépassement d'entier le plus célèbre de ces dernières années est très probablement celui qui causa la destruction de la fusée [Ariane 5](https://www.wikiwand.com/fr/Ariane_5), lors de son [vol inaugural](https://www.wikiwand.com/fr/Vol_501_d'Ariane_5), le 4 juin 1996.

:::{#exm-plus-grand-entier-non-signe}
Quel est le plus grand entier non signé pouvant être représenté avec:

a) 8 bits?
a) 32 bits?
a) $n$ bits?
:::

### Entiers signés

Pour travailler avec des entiers qui peuvent être positifs ou négatifs, il faut inclure le signe du nombre dans sa représentation, et l'on parle alors d'entiers signés.

:::{#def-entiers-signes}
## Entiers signés (représentation signe et module)

Un nombre **entier signé** (généralement représenté dans un octet) est un nombre où le 1^er^ bit (à gauche) est réservé au signe, et les autres bits permettent d'indiquer la valeur absolue du nombre. Pour indiquer qu'un nombre est positif (+), le 1^er^ bit est `0`, et pour un nombre négatif (-), le 1^er^ bit est `1`.
:::

:::{.callout-tip}
## Les entiers signés à taille fixe en `Python`

- `numpy.byte`: entier signé sur 8 bits
- `numpy.short`: entier signé sur 16 bits
- `numpy.intc`: entier signé sur 32 bits
- `numpy.int_`: entier signé sur 64 bits

:::

:::{#exm-completion-tableau-signe-module-4-bits}
Complétez les tableaux suivants qui indiquent la représentation signe et module sur 4 bits.

:::{.columns}

:::{.column width="40%"}
| **Base 2** | **Base 10** |
|:----------:|:-----------:|
|    0000    |             |
|    0001    |             |
|    0010    |             |
|    0011    |             |
|    0100    |             |
|    0101    |             |
|    0110    |             |
|    0111    |             |
:::

:::{.column width="10%"}

:::

:::{.column width="40%"}
| **Base 2** | **Base 10** |
|:----------:|:-----------:|
|    1000    |             |
|    1001    |             |
|    1010    |             |
|    1011    |             |
|    1100    |             |
|    1101    |             |
|    1110    |             |
|    1111    |             |
:::
:::
:::

En utilisant les nombres entiers signés:

- On peut écrire autant de nombres positifs que de négatifs.
- Pour un nombre exprimé avec $n$ bits, les valeurs extrèmes sont $\pm(2^{n-1}-1)$

:::{#exm-valeurs-extremes-4-bits}
Quelles sont les valeurs extrèmes pour des entiers signés représentés sur 4 bits?
:::

:::{.callout-warning}
## Inconvénients de la représentation signe et module

- Il y a deux zéros! Un *zéro* positif (0000 0000) et un *zéro* négatif (1000 0000).
- Les opérations arithmétiques ne se font pas de la même manière qu'habituellement. Par exemple, sur 4 bits:
    - **Base 2**: 0100 + 1011 = 1111
    - **Base 10**: +4 + -3 = -7! (**FAUX!**)
:::

:::{#exm-representation-signe-module-8-bits}
Écrivez la représentation signe et module sur 8 bits de:

a) 15
```{r}
#| engine: tikz
#| echo: false

\begin{tikzpicture}
\draw (0,0) grid (8,1);
\end{tikzpicture}
```
a) -15
```{r}
#| engine: tikz
#| echo: false

\begin{tikzpicture}
\draw (0,0) grid (8,1);
\end{tikzpicture}
```
a) -10
```{r}
#| engine: tikz
#| echo: false

\begin{tikzpicture}
\draw (0,0) grid (8,1);
\end{tikzpicture}
```
a) Quel est l'intervalle de nombres entiers *signés* pouvant être représentés avec:
    i. 8 bits?
    i. 16 bits?
:::

## Représentation des nombres en virgule flottante

La virgule flottante est une méthode d'écriture de nombres fréquemment utilisée dans les ordinateurs, équivalente à la notation scientifique en numération binaire. Elle consiste à représenter un nombre par :

- un signe (égal à −1 ou 1) ;
- une mantisse (aussi appelée significande) ;
- et un exposant (entier relatif, généralement borné).

Par exemple:
$$
1,3254 = \underbrace{13254}_{\text{mantisse}} \times \overbrace{10^{-4}}^{\text{exposant}}
$$

### La norme IEEE754

En informatique, l’IEEE 754 est une norme sur l'arithmétique à virgule flottante mise au point par le *Institute of Electrical and Electronics Engineers*. Elle est la norme la plus employée actuellement pour le calcul des nombres à virgule flottante avec les CPU et les FPU. La norme définit les formats de représentation des nombres à virgule flottante (signe, mantisse, exposant, nombres dénormalisés) et valeurs spéciales (infinis et NaN), en même temps qu’un ensemble d’opérations sur les nombres flottants. Il décrit aussi cinq modes d'arrondi et cinq exceptions (comprenant les conditions dans lesquelles une exception se produit, et ce qui se passe dans ce cas).

#### Format général {.unnumbered}

Un nombre flottant est formé de trois éléments : la mantisse, l'exposant et le signe. Le bit de poids fort est le bit de signe : si ce bit est à 1, le nombre est négatif, et s’il est à 0, le nombre est positif. Les $e$ bits suivants représentent l'exposant biaisé (sauf valeur spéciale), et les $m$ bits suivants ($m$ bits de poids faible) représentent la mantisse.

![Format général d'un nombre en virgule flottante.](https://upload.wikimedia.org/wikipedia/commons/2/29/IEEE754_Format_General.png)

L'exposant peut être positif ou négatif. Cependant, la représentation habituelle des nombres signés (complément à 2) rendrait la comparaison entre les nombres flottants un peu plus difficile. Pour régler ce problème, l'exposant est « biaisé », afin de le stocker sous forme d'un nombre non signé.

Ce biais est de 2e−1 − 1 (e représente le nombre de bits de l'exposant) ; il s'agit donc d'une valeur constante une fois que le nombre de bits e est fixé.

Nous remplaçons $\mathbb{R}$ par l'ensemble $\mathbb{F}$ des nombres à virgules flottantes, dont les membres sont zéro et tous les nombres de la forme:
$$
\pm (1+f) \times 2^e
$$
où $1+f$ représente la mantisse et où
$$
\begin{aligned}
f &= \sum_{i=1}^{m} a_i 2^{-i}, \qquad a_i \in \{0, 1 \} \\
&= a_1 2^{-1}+a_2 2^{-2}+\ldots + a_m 2^{-m}
\end{aligned}
$${#eq-mantisse-1-2}
pour un entier fixé $m$, la taille de la mantisse. L'équation (@eq-mantisse-1-2) représente des nombres dans l'intervalle $[1,2[$. De manière équivalente, nous pouvons écrire
$$
\begin{aligned}
f &= 2^{-m} \sum_{i=1}^{m} a_i 2^{m-i} = 2^{-m} z, \qquad a_i \in \{0, 1 \}
\end{aligned}
$${#eq-mantisse-0-puissance-2}
pour un entier $z$ dans l'ensemble $\{ 0, 1, \ldots, 2^m-1 \}$.

:::{#exm-virgule-flottante-1-bit}
Écrivez toutes les mantisses possibles si le nombre de bits de la mantisse est de 1, c'est-à-dire $m=1$.
:::

:::{#exm-virgule-flottante-2-bits}
Écrivez toutes les mantisses possibles si le nombre de bits de la mantisse est de 2, c'est-à-dire $m=2$.
:::

:::{#def-epsilon-machine}
## L'epsilon d'une machine

L'epsilon d'une machine est défini comme le plus petit nombre qui, ajouté à un, donne un résultat différent de un.

En utilisant l'équation (@eq-mantisse-1-2), nous remarquons que le plus petit nombre (autre que 0) possible est $2^{-m}$.

Pour déterminer l'epsilon de la machine en `Python`, on utilise la commande `sys.float_info.epsilon` du module `sys`.

```{python}
import sys
sys.float_info.epsilon
```
:::

Nous pouvons aussi utiliser un petit programme pour déterminer l'epsilon de la machine.

```{python}
eps = 1.0
while eps + 1 > 1:
    eps /= 2
eps *= 2
print("L'epsilon machine est:", eps)
```

En clair, si nous additionnons un nombre plus petit que l'epsilon machine, le résultat reste inchangé.
```{python}
import sys
eps = sys.float_info.epsilon
print(1+eps, 1+eps/2)
```

[Float Toy](https://evanw.github.io/float-toy/)